import {
  Fragment,
  Teleport,
  Transition,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentScope,
  guardReactiveProps,
  inject,
  isRef,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUpdate,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  ref,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  toDisplayString,
  toRef,
  unref,
  useSlots,
  watch,
  withCtx,
  withKeys,
  withModifiers
} from "./chunk-BPFSQ7MV.js";
import "./chunk-JB7WKI7T.js";

// node_modules/date-fns/esm/_lib/toInteger/index.js
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

// node_modules/date-fns/esm/_lib/requiredArgs/index.js
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}

// node_modules/date-fns/esm/toDate/index.js
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}

// node_modules/date-fns/esm/addDays/index.js
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}

// node_modules/date-fns/esm/addMonths/index.js
function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  var dayOfMonth = date.getDate();
  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}

// node_modules/date-fns/esm/add/index.js
function add(dirtyDate, duration) {
  requiredArgs(2, arguments);
  if (!duration || typeof duration !== "object")
    return new Date(NaN);
  var years = duration.years ? toInteger(duration.years) : 0;
  var months = duration.months ? toInteger(duration.months) : 0;
  var weeks = duration.weeks ? toInteger(duration.weeks) : 0;
  var days = duration.days ? toInteger(duration.days) : 0;
  var hours = duration.hours ? toInteger(duration.hours) : 0;
  var minutes = duration.minutes ? toInteger(duration.minutes) : 0;
  var seconds = duration.seconds ? toInteger(duration.seconds) : 0;
  var date = toDate(dirtyDate);
  var dateWithMonths = months || years ? addMonths(date, months + years * 12) : date;
  var dateWithDays = days || weeks ? addDays(dateWithMonths, days + weeks * 7) : dateWithMonths;
  var minutesToAdd = minutes + hours * 60;
  var secondsToAdd = seconds + minutesToAdd * 60;
  var msToAdd = secondsToAdd * 1e3;
  var finalDate = new Date(dateWithDays.getTime() + msToAdd);
  return finalDate;
}

// node_modules/date-fns/esm/addMilliseconds/index.js
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

// node_modules/date-fns/esm/startOfWeek/index.js
function startOfWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/startOfISOWeek/index.js
function startOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return startOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}

// node_modules/date-fns/esm/getISOWeekYear/index.js
function getISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/startOfISOWeekYear/index.js
function startOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date = startOfISOWeek(fourthOfJanuary);
  return date;
}

// node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

// node_modules/date-fns/esm/startOfDay/index.js
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/differenceInCalendarDays/index.js
var MILLISECONDS_IN_DAY = 864e5;
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
}

// node_modules/date-fns/esm/addYears/index.js
function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}

// node_modules/date-fns/esm/constants/index.js
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var minTime = -maxTime;

// node_modules/date-fns/esm/isDate/index.js
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// node_modules/date-fns/esm/isValid/index.js
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}

// node_modules/date-fns/esm/endOfWeek/index.js
function endOfWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setDate(date.getDate() + diff);
  date.setHours(23, 59, 59, 999);
  return date;
}

// node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
var formatDistance_default = formatDistance;

// node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong_default = formatLong;

// node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};
var formatRelative_default = formatRelative;

// node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js
function buildLocalizeFn(args) {
  return function(dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize_default = localize;

// node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/match/index.js
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match_default = match;

// node_modules/date-fns/esm/locale/en-US/index.js
var locale = {
  code: "en-US",
  formatDistance: formatDistance_default,
  formatLong: formatLong_default,
  formatRelative: formatRelative_default,
  localize: localize_default,
  match: match_default,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var en_US_default = locale;

// node_modules/date-fns/esm/subMilliseconds/index.js
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

// node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js
var MILLISECONDS_IN_DAY2 = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY2) + 1;
}

// node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

// node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js
function startOfUTCWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js
function getUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js
function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  var year = getUTCWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, dirtyOptions);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCWeek/index.js
var MILLISECONDS_IN_WEEK2 = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK2) + 1;
}

// node_modules/date-fns/esm/_lib/addLeadingZeros/index.js
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}

// node_modules/date-fns/esm/_lib/format/lightFormatters/index.js
var formatters = {
  y: function(date, token) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  M: function(date, token) {
    var month = date.getUTCMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  d: function(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  a: function(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  h: function(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  H: function(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  m: function(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  s: function(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  S: function(date, token) {
    var numberOfDigits = token.length;
    var milliseconds2 = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds2 * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var lightFormatters_default = formatters;

// node_modules/date-fns/esm/_lib/format/formatters/index.js
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters2 = {
  G: function(date, token, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  y: function(date, token, localize2) {
    if (token === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return lightFormatters_default.y(date, token);
  },
  Y: function(date, token, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  R: function(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  u: function(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  Q: function(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  q: function(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  M: function(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters_default.M(date, token);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  L: function(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  w: function(date, token, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  },
  I: function(date, token, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  d: function(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return lightFormatters_default.d(date, token);
  },
  D: function(date, token, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  E: function(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  e: function(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  c: function(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  i: function(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  a: function(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  b: function(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  B: function(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  h: function(date, token, localize2) {
    if (token === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return lightFormatters_default.h(date, token);
  },
  H: function(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return lightFormatters_default.H(date, token);
  },
  K: function(date, token, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  k: function(date, token, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  m: function(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return lightFormatters_default.m(date, token);
  },
  s: function(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return lightFormatters_default.s(date, token);
  },
  S: function(date, token) {
    return lightFormatters_default.S(date, token);
  },
  X: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  x: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  O: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  z: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  t: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  T: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
var formatters_default = formatters2;

// node_modules/date-fns/esm/_lib/format/longFormatters/index.js
function dateLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
}
function timeLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
}
function dateTimeLongFormatter(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
}
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters_default = longFormatters;

// node_modules/date-fns/esm/_lib/protectedTokens/index.js
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format2, input) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  }
}

// node_modules/date-fns/esm/format/index.js
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var locale2 = options.locale || en_US_default;
  var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters_default[firstCharacter];
      return longFormatter(substring, locale2.formatLong, formatterOptions);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters_default[firstCharacter];
    if (formatter) {
      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }
      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

// node_modules/date-fns/esm/_lib/assign/index.js
function assign(target, dirtyObject) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  dirtyObject = dirtyObject || {};
  for (var property in dirtyObject) {
    if (Object.prototype.hasOwnProperty.call(dirtyObject, property)) {
      target[property] = dirtyObject[property];
    }
  }
  return target;
}

// node_modules/date-fns/esm/formatDistanceStrict/index.js
var MILLISECONDS_IN_MINUTE = 1e3 * 60;
var MINUTES_IN_DAY = 60 * 24;
var MINUTES_IN_MONTH = MINUTES_IN_DAY * 30;
var MINUTES_IN_YEAR = MINUTES_IN_DAY * 365;

// node_modules/date-fns/esm/getDay/index.js
function getDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var day = date.getDay();
  return day;
}

// node_modules/date-fns/esm/getDaysInMonth/index.js
function getDaysInMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth2 = new Date(0);
  lastDayOfMonth2.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth2.setHours(0, 0, 0, 0);
  return lastDayOfMonth2.getDate();
}

// node_modules/date-fns/esm/getHours/index.js
function getHours(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var hours = date.getHours();
  return hours;
}

// node_modules/date-fns/esm/getISOWeek/index.js
var MILLISECONDS_IN_WEEK3 = 6048e5;
function getISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfISOWeek(date).getTime() - startOfISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK3) + 1;
}

// node_modules/date-fns/esm/getMinutes/index.js
function getMinutes(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var minutes = date.getMinutes();
  return minutes;
}

// node_modules/date-fns/esm/getMonth/index.js
function getMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  return month;
}

// node_modules/date-fns/esm/getOverlappingDaysInIntervals/index.js
var MILLISECONDS_IN_DAY3 = 24 * 60 * 60 * 1e3;

// node_modules/date-fns/esm/getSeconds/index.js
function getSeconds(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var seconds = date.getSeconds();
  return seconds;
}

// node_modules/date-fns/esm/getYear/index.js
function getYear(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getFullYear();
}

// node_modules/date-fns/esm/subDays/index.js
function subDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}

// node_modules/date-fns/esm/subMonths/index.js
function subMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, -amount);
}

// node_modules/date-fns/esm/sub/index.js
function sub(date, duration) {
  requiredArgs(2, arguments);
  if (!duration || typeof duration !== "object")
    return new Date(NaN);
  var years = duration.years ? toInteger(duration.years) : 0;
  var months = duration.months ? toInteger(duration.months) : 0;
  var weeks = duration.weeks ? toInteger(duration.weeks) : 0;
  var days = duration.days ? toInteger(duration.days) : 0;
  var hours = duration.hours ? toInteger(duration.hours) : 0;
  var minutes = duration.minutes ? toInteger(duration.minutes) : 0;
  var seconds = duration.seconds ? toInteger(duration.seconds) : 0;
  var dateWithoutMonths = subMonths(date, months + years * 12);
  var dateWithoutDays = subDays(dateWithoutMonths, days + weeks * 7);
  var minutestoSub = minutes + hours * 60;
  var secondstoSub = seconds + minutestoSub * 60;
  var mstoSub = secondstoSub * 1e3;
  var finalDate = new Date(dateWithoutDays.getTime() - mstoSub);
  return finalDate;
}

// node_modules/date-fns/esm/isAfter/index.js
function isAfter(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}

// node_modules/date-fns/esm/isBefore/index.js
function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}

// node_modules/date-fns/esm/isEqual/index.js
function isEqual(dirtyLeftDate, dirtyRightDate) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyLeftDate);
  var dateRight = toDate(dirtyRightDate);
  return dateLeft.getTime() === dateRight.getTime();
}

// node_modules/date-fns/esm/_lib/setUTCDay/index.js
function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
  requiredArgs(2, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// node_modules/date-fns/esm/_lib/setUTCISODay/index.js
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// node_modules/date-fns/esm/_lib/setUTCISOWeek/index.js
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

// node_modules/date-fns/esm/_lib/setUTCWeek/index.js
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

// node_modules/date-fns/esm/parse/_lib/parsers/index.js
var MILLISECONDS_IN_HOUR = 36e5;
var MILLISECONDS_IN_MINUTE2 = 6e4;
var MILLISECONDS_IN_SECOND = 1e3;
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  date: /^(3[0-1]|[0-2]?\d)/,
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  week: /^(5[0-3]|[0-4]?\d)/,
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  hour11h: /^(1[0-1]|0?\d)/,
  hour12h: /^(1[0-2]|0?\d)/,
  minute: /^[0-5]?\d/,
  second: /^[0-5]?\d/,
  singleDigit: /^\d/,
  twoDigits: /^\d{1,2}/,
  threeDigits: /^\d{1,3}/,
  fourDigits: /^\d{1,4}/,
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  twoDigitsSigned: /^-?\d{1,2}/,
  threeDigitsSigned: /^-?\d{1,3}/,
  fourDigitsSigned: /^-?\d{1,4}/
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function parseNumericPattern(pattern, string, valueCallback) {
  var matchResult = string.match(pattern);
  if (!matchResult) {
    return null;
  }
  var value = parseInt(matchResult[0], 10);
  return {
    value: valueCallback ? valueCallback(value) : value,
    rest: string.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, string) {
  var matchResult = string.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: string.slice(1)
    };
  }
  var sign = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE2 + seconds * MILLISECONDS_IN_SECOND),
    rest: string.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(string, valueCallback) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, string, valueCallback);
}
function parseNDigits(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, string, valueCallback);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, string, valueCallback);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, string, valueCallback);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, string, valueCallback);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), string, valueCallback);
  }
}
function parseNDigitsSigned(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, string, valueCallback);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, string, valueCallback);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, string, valueCallback);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, string, valueCallback);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), string, valueCallback);
  }
}
function dayPeriodEnumToHours(enumValue) {
  switch (enumValue) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
var parsers = {
  G: {
    priority: 140,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "G":
        case "GG":
        case "GGG":
          return match2.era(string, {
            width: "abbreviated"
          }) || match2.era(string, {
            width: "narrow"
          });
        case "GGGGG":
          return match2.era(string, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return match2.era(string, {
            width: "wide"
          }) || match2.era(string, {
            width: "abbreviated"
          }) || match2.era(string, {
            width: "narrow"
          });
      }
    },
    set: function(date, flags, value, _options) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["R", "u", "t", "T"]
  },
  y: {
    priority: 130,
    parse: function(string, token, match2, _options) {
      var valueCallback = function(year) {
        return {
          year,
          isTwoDigitYear: token === "yy"
        };
      };
      switch (token) {
        case "y":
          return parseNDigits(4, string, valueCallback);
        case "yo":
          return match2.ordinalNumber(string, {
            unit: "year",
            valueCallback
          });
        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function(_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function(date, flags, value, _options) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]
  },
  Y: {
    priority: 130,
    parse: function(string, token, match2, _options) {
      var valueCallback = function(year) {
        return {
          year,
          isTwoDigitYear: token === "YY"
        };
      };
      switch (token) {
        case "Y":
          return parseNDigits(4, string, valueCallback);
        case "Yo":
          return match2.ordinalNumber(string, {
            unit: "year",
            valueCallback
          });
        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function(_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    },
    incompatibleTokens: ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]
  },
  R: {
    priority: 130,
    parse: function(string, token, _match, _options) {
      if (token === "R") {
        return parseNDigitsSigned(4, string);
      }
      return parseNDigitsSigned(token.length, string);
    },
    set: function(_date, _flags, value, _options) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    },
    incompatibleTokens: ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]
  },
  u: {
    priority: 130,
    parse: function(string, token, _match, _options) {
      if (token === "u") {
        return parseNDigitsSigned(4, string);
      }
      return parseNDigitsSigned(token.length, string);
    },
    set: function(date, _flags, value, _options) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]
  },
  Q: {
    priority: 120,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "Q":
        case "QQ":
          return parseNDigits(token.length, string);
        case "Qo":
          return match2.ordinalNumber(string, {
            unit: "quarter"
          });
        case "QQQ":
          return match2.quarter(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(string, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return match2.quarter(string, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return match2.quarter(string, {
            width: "wide",
            context: "formatting"
          }) || match2.quarter(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]
  },
  q: {
    priority: 120,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "q":
        case "qq":
          return parseNDigits(token.length, string);
        case "qo":
          return match2.ordinalNumber(string, {
            unit: "quarter"
          });
        case "qqq":
          return match2.quarter(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(string, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return match2.quarter(string, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return match2.quarter(string, {
            width: "wide",
            context: "standalone"
          }) || match2.quarter(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(string, {
            width: "narrow",
            context: "standalone"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]
  },
  M: {
    priority: 110,
    parse: function(string, token, match2, _options) {
      var valueCallback = function(value) {
        return value - 1;
      };
      switch (token) {
        case "M":
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        case "MM":
          return parseNDigits(2, string, valueCallback);
        case "Mo":
          return match2.ordinalNumber(string, {
            unit: "month",
            valueCallback
          });
        case "MMM":
          return match2.month(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(string, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMMM":
          return match2.month(string, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return match2.month(string, {
            width: "wide",
            context: "formatting"
          }) || match2.month(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]
  },
  L: {
    priority: 110,
    parse: function(string, token, match2, _options) {
      var valueCallback = function(value) {
        return value - 1;
      };
      switch (token) {
        case "L":
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        case "LL":
          return parseNDigits(2, string, valueCallback);
        case "Lo":
          return match2.ordinalNumber(string, {
            unit: "month",
            valueCallback
          });
        case "LLL":
          return match2.month(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(string, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLLL":
          return match2.month(string, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return match2.month(string, {
            width: "wide",
            context: "standalone"
          }) || match2.month(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(string, {
            width: "narrow",
            context: "standalone"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]
  },
  w: {
    priority: 100,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "w":
          return parseNumericPattern(numericPatterns.week, string);
        case "wo":
          return match2.ordinalNumber(string, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    },
    incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]
  },
  I: {
    priority: 100,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "I":
          return parseNumericPattern(numericPatterns.week, string);
        case "Io":
          return match2.ordinalNumber(string, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function(date, _flags, value, options) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value, options), options);
    },
    incompatibleTokens: ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]
  },
  d: {
    priority: 90,
    subPriority: 1,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "d":
          return parseNumericPattern(numericPatterns.date, string);
        case "do":
          return match2.ordinalNumber(string, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear2 = isLeapYearIndex(year);
      var month = date.getUTCMonth();
      if (isLeapYear2) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]
  },
  D: {
    priority: 90,
    subPriority: 1,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, string);
        case "Do":
          return match2.ordinalNumber(string, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear2 = isLeapYearIndex(year);
      if (isLeapYear2) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]
  },
  E: {
    priority: 90,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "E":
        case "EE":
        case "EEE":
          return match2.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEE":
          return match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEE":
        default:
          return match2.day(string, {
            width: "wide",
            context: "formatting"
          }) || match2.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["D", "i", "e", "c", "t", "T"]
  },
  e: {
    priority: 90,
    parse: function(string, token, match2, options) {
      var valueCallback = function(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "e":
        case "ee":
          return parseNDigits(token.length, string, valueCallback);
        case "eo":
          return match2.ordinalNumber(string, {
            unit: "day",
            valueCallback
          });
        case "eee":
          return match2.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeee":
          return match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "eeee":
        default:
          return match2.day(string, {
            width: "wide",
            context: "formatting"
          }) || match2.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]
  },
  c: {
    priority: 90,
    parse: function(string, token, match2, options) {
      var valueCallback = function(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "c":
        case "cc":
          return parseNDigits(token.length, string, valueCallback);
        case "co":
          return match2.ordinalNumber(string, {
            unit: "day",
            valueCallback
          });
        case "ccc":
          return match2.day(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(string, {
            width: "short",
            context: "standalone"
          }) || match2.day(string, {
            width: "narrow",
            context: "standalone"
          });
        case "ccccc":
          return match2.day(string, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return match2.day(string, {
            width: "short",
            context: "standalone"
          }) || match2.day(string, {
            width: "narrow",
            context: "standalone"
          });
        case "cccc":
        default:
          return match2.day(string, {
            width: "wide",
            context: "standalone"
          }) || match2.day(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(string, {
            width: "short",
            context: "standalone"
          }) || match2.day(string, {
            width: "narrow",
            context: "standalone"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]
  },
  i: {
    priority: 90,
    parse: function(string, token, match2, _options) {
      var valueCallback = function(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        case "i":
        case "ii":
          return parseNDigits(token.length, string);
        case "io":
          return match2.ordinalNumber(string, {
            unit: "day"
          });
        case "iii":
          return match2.day(string, {
            width: "abbreviated",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "short",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
        case "iiiii":
          return match2.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
        case "iiiiii":
          return match2.day(string, {
            width: "short",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
        case "iiii":
        default:
          return match2.day(string, {
            width: "wide",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "abbreviated",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "short",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 7;
    },
    set: function(date, _flags, value, options) {
      date = setUTCISODay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]
  },
  a: {
    priority: 80,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "a":
        case "aa":
        case "aaa":
          return match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match2.dayPeriod(string, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["b", "B", "H", "k", "t", "T"]
  },
  b: {
    priority: 80,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "b":
        case "bb":
        case "bbb":
          return match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match2.dayPeriod(string, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "B", "H", "k", "t", "T"]
  },
  B: {
    priority: 80,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match2.dayPeriod(string, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "b", "t", "T"]
  },
  h: {
    priority: 70,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, string);
        case "ho":
          return match2.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 12;
    },
    set: function(date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    },
    incompatibleTokens: ["H", "K", "k", "t", "T"]
  },
  H: {
    priority: 70,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, string);
        case "Ho":
          return match2.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 23;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "b", "h", "K", "k", "t", "T"]
  },
  K: {
    priority: 70,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, string);
        case "Ko":
          return match2.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function(date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    },
    incompatibleTokens: ["h", "H", "k", "t", "T"]
  },
  k: {
    priority: 70,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, string);
        case "ko":
          return match2.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 24;
    },
    set: function(date, _flags, value, _options) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "b", "h", "H", "K", "t", "T"]
  },
  m: {
    priority: 60,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, string);
        case "mo":
          return match2.ordinalNumber(string, {
            unit: "minute"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    },
    incompatibleTokens: ["t", "T"]
  },
  s: {
    priority: 50,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "s":
          return parseNumericPattern(numericPatterns.second, string);
        case "so":
          return match2.ordinalNumber(string, {
            unit: "second"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCSeconds(value, 0);
      return date;
    },
    incompatibleTokens: ["t", "T"]
  },
  S: {
    priority: 30,
    parse: function(string, token, _match, _options) {
      var valueCallback = function(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };
      return parseNDigits(token.length, string, valueCallback);
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMilliseconds(value);
      return date;
    },
    incompatibleTokens: ["t", "T"]
  },
  X: {
    priority: 10,
    parse: function(string, token, _match, _options) {
      switch (token) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, string);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function(date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ["t", "T", "x"]
  },
  x: {
    priority: 10,
    parse: function(string, token, _match, _options) {
      switch (token) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, string);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function(date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ["t", "T", "X"]
  },
  t: {
    priority: 40,
    parse: function(string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function(_date, _flags, value, _options) {
      return [new Date(value * 1e3), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: "*"
  },
  T: {
    priority: 20,
    parse: function(string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function(_date, _flags, value, _options) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: "*"
  }
};
var parsers_default = parsers;

// node_modules/date-fns/esm/parse/index.js
var TIMEZONE_UNIT_PRIORITY = 10;
var formattingTokensRegExp2 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp2 = /^'([^]*?)'?$/;
var doubleQuoteRegExp2 = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp2 = /[a-zA-Z]/;
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, dirtyOptions) {
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var options = dirtyOptions || {};
  var locale2 = options.locale || en_US_default;
  if (!locale2.match) {
    throw new RangeError("locale must contain match property");
  }
  var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  var setters = [{
    priority: TIMEZONE_UNIT_PRIORITY,
    subPriority: -1,
    set: dateToSystemTimezone,
    index: 0
  }];
  var i;
  var tokens = formatString.match(longFormattingTokensRegExp2).map(function(substring) {
    var firstCharacter2 = substring[0];
    if (firstCharacter2 === "p" || firstCharacter2 === "P") {
      var longFormatter = longFormatters_default[firstCharacter2];
      return longFormatter(substring, locale2.formatLong, subFnOptions);
    }
    return substring;
  }).join("").match(formattingTokensRegExp2);
  var usedTokens = [];
  for (i = 0; i < tokens.length; i++) {
    var token = tokens[i];
    if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token)) {
      throwProtectedError(token, formatString, dirtyDateString);
    }
    if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
      throwProtectedError(token, formatString, dirtyDateString);
    }
    var firstCharacter = token[0];
    var parser = parsers_default[firstCharacter];
    if (parser) {
      var incompatibleTokens = parser.incompatibleTokens;
      if (Array.isArray(incompatibleTokens)) {
        var incompatibleToken = void 0;
        for (var _i = 0; _i < usedTokens.length; _i++) {
          var usedToken = usedTokens[_i].token;
          if (incompatibleTokens.indexOf(usedToken) !== -1 || usedToken === firstCharacter) {
            incompatibleToken = usedTokens[_i];
            break;
          }
        }
        if (incompatibleToken) {
          throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
        }
      } else if (parser.incompatibleTokens === "*" && usedTokens.length) {
        throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
      }
      usedTokens.push({
        token: firstCharacter,
        fullToken: token
      });
      var parseResult = parser.parse(dateString, token, locale2.match, subFnOptions);
      if (!parseResult) {
        return new Date(NaN);
      }
      setters.push({
        priority: parser.priority,
        subPriority: parser.subPriority || 0,
        set: parser.set,
        validate: parser.validate,
        value: parseResult.value,
        index: setters.length
      });
      dateString = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp2)) {
        throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
      }
      if (token === "''") {
        token = "'";
      } else if (firstCharacter === "'") {
        token = cleanEscapedString2(token);
      }
      if (dateString.indexOf(token) === 0) {
        dateString = dateString.slice(token.length);
      } else {
        return new Date(NaN);
      }
    }
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a, b) {
    return b - a;
  }).filter(function(priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date)) {
    return new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  for (i = 0; i < uniquePrioritySetters.length; i++) {
    var setter = uniquePrioritySetters[i];
    if (setter.validate && !setter.validate(utcDate, setter.value, subFnOptions)) {
      return new Date(NaN);
    }
    var result = setter.set(utcDate, flags, setter.value, subFnOptions);
    if (result[0]) {
      utcDate = result[0];
      assign(flags, result[1]);
    } else {
      utcDate = result;
    }
  }
  return utcDate;
}
function dateToSystemTimezone(date, flags) {
  if (flags.timestampIsSet) {
    return date;
  }
  var convertedDate = new Date(0);
  convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
  convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
  return convertedDate;
}
function cleanEscapedString2(input) {
  return input.match(escapedStringRegExp2)[1].replace(doubleQuoteRegExp2, "'");
}

// node_modules/date-fns/esm/setMonth/index.js
function setMonth(dirtyDate, dirtyMonth) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var month = toInteger(dirtyMonth);
  var year = date.getFullYear();
  var day = date.getDate();
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  date.setMonth(month, Math.min(day, daysInMonth));
  return date;
}

// node_modules/date-fns/esm/set/index.js
function set(dirtyDate, values) {
  requiredArgs(2, arguments);
  if (typeof values !== "object" || values === null) {
    throw new RangeError("values parameter must be an object");
  }
  var date = toDate(dirtyDate);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  if (values.year != null) {
    date.setFullYear(values.year);
  }
  if (values.month != null) {
    date = setMonth(date, values.month);
  }
  if (values.date != null) {
    date.setDate(toInteger(values.date));
  }
  if (values.hours != null) {
    date.setHours(toInteger(values.hours));
  }
  if (values.minutes != null) {
    date.setMinutes(toInteger(values.minutes));
  }
  if (values.seconds != null) {
    date.setSeconds(toInteger(values.seconds));
  }
  if (values.milliseconds != null) {
    date.setMilliseconds(toInteger(values.milliseconds));
  }
  return date;
}

// node_modules/date-fns/esm/setHours/index.js
function setHours(dirtyDate, dirtyHours) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var hours = toInteger(dirtyHours);
  date.setHours(hours);
  return date;
}

// node_modules/date-fns/esm/setMilliseconds/index.js
function setMilliseconds(dirtyDate, dirtyMilliseconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var milliseconds2 = toInteger(dirtyMilliseconds);
  date.setMilliseconds(milliseconds2);
  return date;
}

// node_modules/date-fns/esm/setMinutes/index.js
function setMinutes(dirtyDate, dirtyMinutes) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var minutes = toInteger(dirtyMinutes);
  date.setMinutes(minutes);
  return date;
}

// node_modules/date-fns/esm/setSeconds/index.js
function setSeconds(dirtyDate, dirtySeconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var seconds = toInteger(dirtySeconds);
  date.setSeconds(seconds);
  return date;
}

// node_modules/date-fns/esm/setYear/index.js
function setYear(dirtyDate, dirtyYear) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var year = toInteger(dirtyYear);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  date.setFullYear(year);
  return date;
}

// node_modules/date-fns/esm/subYears/index.js
function subYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addYears(dirtyDate, -amount);
}

// node_modules/@vuepic/vue-datepicker/dist/vue-datepicker.es.js
var Fn = Object.defineProperty;
var Ln = Object.defineProperties;
var Hn = Object.getOwnPropertyDescriptors;
var en = Object.getOwnPropertySymbols;
var Wn = Object.prototype.hasOwnProperty;
var Un = Object.prototype.propertyIsEnumerable;
var tn = (e, l, n) => l in e ? Fn(e, l, { enumerable: true, configurable: true, writable: true, value: n }) : e[l] = n;
var K = (e, l) => {
  for (var n in l || (l = {}))
    Wn.call(l, n) && tn(e, n, l[n]);
  if (en)
    for (var n of en(l))
      Un.call(l, n) && tn(e, n, l[n]);
  return e;
};
var ce = (e, l) => Ln(e, Hn(l));
var ze = (e, l) => {
  const n = e.__vccOpts || e;
  for (const [t, i] of l)
    n[t] = i;
  return n;
};
var la = {};
var oa = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" };
var ra = createBaseVNode("path", { d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z" }, null, -1);
var sa = createBaseVNode("path", { d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1);
var ua = createBaseVNode("path", { d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1);
var ia = createBaseVNode("path", { d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z" }, null, -1);
var da = [ra, sa, ua, ia];
function ma(e, l) {
  return openBlock(), createElementBlock("svg", oa, da);
}
var $t = ze(la, [["render", ma]]);
var ca = {};
var pa = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" };
var va = createBaseVNode("path", { d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z" }, null, -1);
var fa = createBaseVNode("path", { d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1);
var ya = [va, fa];
function ha(e, l) {
  return openBlock(), createElementBlock("svg", pa, ya);
}
var ga = ze(ca, [["render", ha]]);
var wa = {};
var ka = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" };
var ba = createBaseVNode("path", { d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1);
var $a = [ba];
function Da(e, l) {
  return openBlock(), createElementBlock("svg", ka, $a);
}
var vn = ze(wa, [["render", Da]]);
var Ma = {};
var Sa = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" };
var Ca = createBaseVNode("path", { d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z" }, null, -1);
var Pa = [Ca];
function Aa(e, l) {
  return openBlock(), createElementBlock("svg", Sa, Pa);
}
var fn = ze(Ma, [["render", Aa]]);
var Ta = {};
var _a = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" };
var Oa = createBaseVNode("path", { d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z" }, null, -1);
var Va = createBaseVNode("path", { d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1);
var Na = [Oa, Va];
function Ia(e, l) {
  return openBlock(), createElementBlock("svg", _a, Na);
}
var yn = ze(Ta, [["render", Ia]]);
var Ba = {};
var Ra = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" };
var Ya = createBaseVNode("path", { d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1);
var Ea = [Ya];
function Fa(e, l) {
  return openBlock(), createElementBlock("svg", Ra, Ea);
}
var hn = ze(Ba, [["render", Fa]]);
var La = {};
var Ha = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" };
var Wa = createBaseVNode("path", { d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1);
var Ua = [Wa];
function Ka(e, l) {
  return openBlock(), createElementBlock("svg", Ha, Ua);
}
var gn = ze(La, [["render", Ka]]);
var Et = (e, l) => {
  const n = parse(e, l.slice(0, e.length), new Date());
  return isValid(n) && isDate(n) ? n : null;
};
var _e = (e) => {
  let l = new Date(JSON.parse(JSON.stringify(e)));
  return l = setHours(l, 0), l = setMinutes(l, 0), l = setSeconds(l, 0), l = setMilliseconds(l, 0), l;
};
var Ft = (e) => Array.isArray(e) ? isValid(e[0]) && (e[1] ? isValid(e[1]) : true) : e ? isValid(e) : false;
var ve = (e, l, n, t) => {
  let i = e ? new Date(e) : new Date();
  return (l || l === 0) && (i = setHours(i, +l)), (n || n === 0) && (i = setMinutes(i, +n)), (t || t === 0) && (i = setSeconds(i, +t)), setMilliseconds(i, 0);
};
var ja = (e) => {
  const l = addMonths(e, 1);
  return { month: getMonth(l), year: getYear(l) };
};
var Xe = (e, l, n) => {
  let t = e ? new Date(e) : new Date();
  return (l || l === 0) && (t = setMonth(t, l)), n && (t = setYear(t, n)), t;
};
var wn = (e, l) => e ? `HH:mm${l ? ":ss" : ""}` : `hh:mm${l ? ":ss" : ""} aa`;
var kn = (e, l, n, t, i, g, b) => e || (t ? "MM/yyyy" : i ? wn(l, n) : g ? "MM/dd/yyyy" : b ? `MM/dd/yyyy, ${wn(l, n)}` : "MM/dd/yyyy");
var Lt = (e) => {
  const l = e || new Date();
  return { hours: getHours(l), minutes: getMinutes(l), seconds: getSeconds(l) };
};
var Dt = (e) => ({ month: getMonth(e), year: getYear(e) });
var bn = (e) => Array.isArray(e) ? [Dt(e[0]), e[1] ? Dt(e[1]) : null] : Dt(e);
var Ht = (e) => Array.isArray(e) ? [Lt(e[0]), Lt(e[1])] : Lt(e);
var Wt = (e, l, n) => n ? format(e, l, { locale: n }) : format(e, l);
var Mt = (e, l, n, t) => Array.isArray(e) ? `${Wt(e[0], l, n)} ${t || "-"} ${e[1] ? Wt(e[1], l, n) : ""}` : Wt(e, l, n);
var ge = (e, l) => !e || !l ? false : isAfter(_e(e), _e(l));
var de = (e, l) => !e || !l ? false : isBefore(_e(e), _e(l));
var te = (e, l) => !e || !l ? false : isEqual(_e(e), _e(l));
var Ga = (e, l) => add(set(new Date(), e), l);
var za = (e, l) => sub(set(new Date(), e), l);
var Ut = (e) => set(new Date(), { hours: getHours(e), minutes: getMinutes(e), seconds: getSeconds(e) });
var $n = (e) => set(new Date(), { hours: +e.hours || 0, minutes: +e.minutes || 0, seconds: +e.seconds || 0 });
var Kt = (e, l, n) => {
  let t = true;
  if (!e)
    return true;
  const i = Array.isArray(e) ? [e[0] ? Ut(e[0]) : null, e[1] ? Ut(e[1]) : null] : Ut(e);
  if (l) {
    const g = $n(l);
    Array.isArray(i) ? t = (i[0] ? i[0].getTime() <= g.getTime() : true) && (i[1] ? i[1].getTime() <= g.getTime() : true) : t = i.getTime() <= g.getTime();
  }
  if (n) {
    const g = $n(n);
    Array.isArray(i) ? t = (i[0] ? i[0].getTime() >= g.getTime() : true) && (i[1] ? i[1].getTime() >= g.getTime() : true) && t : t = i.getTime() >= g.getTime() && t;
  }
  return t;
};
var Xa = (e, l, n) => {
  let t = true;
  return l && n && (t = ge(new Date(e), new Date(l)) && de(new Date(e), new Date(n))), l && (t = ge(new Date(e), new Date(l))), n && (t = de(new Date(e), new Date(n))), t;
};
var be = (e) => {
  const l = Date.UTC(e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds());
  return new Date(l).toISOString();
};
var Dn = (e, l, n) => e && e[0] && e[1] ? ge(n, e[0]) && de(n, e[1]) : e && e[0] && l ? ge(n, e[0]) && de(n, l) || de(n, e[0]) && ge(n, l) : false;
var St = (e, l) => {
  const n = startOfWeek(e, { weekStartsOn: l }), t = endOfWeek(e, { weekStartsOn: l });
  return [n, t];
};
var qa = (e, l, n) => {
  const t = new Date(JSON.parse(JSON.stringify(e))), i = [];
  for (let g = 0; g < 7; g++) {
    const b = addDays(t, g), k = getMonth(b) !== l;
    i.push({ text: n && k ? "" : b.getDate(), value: b, current: !k });
  }
  return i;
};
var Ja = (e, l, n, t) => {
  const i = [], g = new Date(l, e), b = new Date(l, e + 1, 0), k = startOfWeek(g, { weekStartsOn: n }), p = (w) => {
    const h = qa(w, e, t);
    if (i.push({ days: h }), !i[i.length - 1].days.some((O) => te(_e(O.value), _e(b)))) {
      const O = addDays(w, 7);
      p(O);
    }
  };
  return p(k), i;
};
var Za = (e, l = 3) => {
  const n = [];
  for (let t = 0; t < e.length; t += l)
    n.push([e[t], e[t + 1], e[t + 2]]);
  return n;
};
var Qa = (e, l) => {
  const n = [1, 2, 3, 4, 5, 6, 7].map((g) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(new Date(`2017-01-0${g}T00:00:00+00:00`)).slice(0, 2)), t = n.slice(0, l), i = n.slice(l + 1, n.length);
  return [n[l]].concat(...i).concat(...t);
};
var xa = (e) => {
  const l = [];
  for (let n = +e[0]; n <= +e[1]; n++)
    l.push({ value: +n, text: `${n}` });
  return l;
};
var el = (e, l) => {
  const n = new Intl.DateTimeFormat(e, { month: l, timeZone: "UTC" });
  return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((t) => {
    const i = t < 10 ? `0${t}` : t;
    return new Date(`2017-${i}-01T00:00:00+00:00`);
  }).map((t, i) => ({ text: n.format(t), value: i }));
};
var tl = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e];
var nl = () => ({ enterSubmit: true, tabSubmit: true, openMenu: true, rangeSeparator: " - " });
var al = (e) => Object.assign({ months: [], years: [], times: { hours: [], minutes: [], seconds: [] } }, e);
var ll = (e) => {
  function l(n) {
    let t = "";
    const i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", g = i.length;
    for (let b = 0; b < n; b++)
      t += i.charAt(Math.floor(Math.random() * g));
    return t + e;
  }
  return l(5);
};
var we = (e) => {
  var n;
  const l = unref(e);
  return (n = l == null ? void 0 : l.$el) != null ? n : l;
};
var ol = (e) => Object.assign({ type: "dot" }, e);
var Mn = (e) => Object.assign({ menuAppear: "dp-menu-appear", open: "dp-slide-down", close: "dp-slide-up", next: "calendar-next", previous: "calendar-prev", vNext: "dp-slide-up", vPrevious: "dp-slide-down" }, e);
var rl = (e) => Object.assign({ toggleOverlay: "Toggle overlay", menu: "Datepicker menu", input: "Datepicker input", calendarWrap: "Calendar wrapper", calendarDays: "Calendar days", openTimePicker: "Open time picker", closeTimePicker: "Close time Picker", incrementValue: (l) => `Increment ${l}`, decrementValue: (l) => `Decrement ${l}`, openTpOverlay: (l) => `Open ${l} overlay`, amPmButton: "Switch AM/PM mode", openYearsOverlay: "Open years overlay", openMonthsOverlay: "Open months overlay", nextMonth: "Next month", prevMonth: "Previous month" }, e);
var Le = Symbol();
var Ct = Symbol();
var jt = Symbol();
var Sn = Symbol();
var Cn = Symbol();
var Gt = { disabled: { type: Boolean, default: false }, readonly: { type: Boolean, default: false }, autoApply: { type: Boolean, default: false }, inline: { type: Boolean, default: false }, textInput: { type: Boolean, default: false } };
var zt = { range: { type: Boolean, default: false }, uid: { type: String, default: null } };
var Pn = { enableSeconds: { type: Boolean, default: false }, is24: { type: Boolean, default: true }, noHoursOverlay: { type: Boolean, default: false }, noMinutesOverlay: { type: Boolean, default: false }, noSecondsOverlay: { type: Boolean, default: false }, hoursGridIncrement: { type: [String, Number], default: 1 }, minutesGridIncrement: { type: [String, Number], default: 5 }, secondsGridIncrement: { type: [String, Number], default: 5 }, hoursIncrement: { type: [Number, String], default: 1 }, minutesIncrement: { type: [Number, String], default: 1 }, secondsIncrement: { type: [Number, String], default: 1 } };
var An = ce(K({}, Pn), { fixedStart: { type: Boolean, default: false }, fixedEnd: { type: Boolean, default: false }, timePicker: { type: Boolean, default: false } });
var Tn = { name: { type: String, default: null }, placeholder: { type: String, default: "" }, hideInputIcon: { type: Boolean, default: false }, clearable: { type: Boolean, default: true }, state: { type: Boolean, default: null }, required: { type: Boolean, default: false }, autocomplete: { type: String, default: "off" }, inputClassName: { type: String, default: null }, inlineWithInput: { type: Boolean, default: false }, textInputOptions: { type: Object, default: () => null }, openMenuOnFocus: { type: Boolean, default: true } };
var _n = { minTime: { type: Object, default: null }, maxTime: { type: Object, default: null } };
var Xt = { minDate: { type: [Date, String], default: null }, maxDate: { type: [Date, String], default: null } };
var On = K({ selectText: { type: String, default: "Select" }, cancelText: { type: String, default: "Cancel" }, previewFormat: { type: [String, Function], default: () => "" }, multiDates: { type: Boolean, default: false } }, _n);
var qt = { monthPicker: { type: Boolean, default: false }, customProps: { type: Object, default: null } };
var Vn = { locale: { type: String, default: "en-Us" }, weekNumName: { type: String, default: "W" }, weekStart: { type: [Number, String], default: 1 }, weekNumbers: { type: Boolean, default: false }, calendarClassName: { type: String, default: null }, noSwipe: { type: Boolean, default: false } };
var Nn = ce(K(K(K(K(K(K({}, An), On), qt), Xt), Vn), zt), { vertical: { type: Boolean, default: false }, disableMonthYearSelect: { type: Boolean, default: false }, menuClassName: { type: String, default: null }, yearRange: { type: Array, default: () => [1970, 2100] }, multiCalendarsSolo: { type: Boolean, default: false }, calendarCellClassName: { type: String, default: null }, enableTimePicker: { type: Boolean, default: true }, autoApply: { type: Boolean, default: false }, disabledDates: { type: [Array, Function], default: () => [] }, monthNameFormat: { type: String, default: "short" }, startDate: { type: [Date, String], default: null }, startTime: { type: [Object, Array], default: null }, monthYearComponent: { type: Object, default: null }, timePickerComponent: { type: Object, default: null }, actionRowComponent: { type: Object, default: null }, hideOffsetDates: { type: Boolean, default: false }, autoRange: { type: [Number, String], default: null }, noToday: { type: Boolean, default: false }, disabledWeekDays: { type: Array, default: () => [] }, allowedDates: { type: Array, default: () => [] }, showNowButton: { type: Boolean, default: false }, nowButtonLabel: { type: String, default: "Now" }, monthChangeOnScroll: { type: [Boolean, String], default: true }, markers: { type: Array, default: () => [] }, modeHeight: { type: [Number, String], default: 255 }, escClose: { type: Boolean, default: true }, spaceConfirm: { type: Boolean, default: true }, monthChangeOnArrows: { type: Boolean, default: true }, presetRanges: { type: Array, default: () => [] }, flow: { type: Array, default: () => [] }, preventMinMaxNavigation: { type: Boolean, default: false }, minRange: { type: [Number, String], default: null }, maxRange: { type: [Number, String], default: null }, multiDatesLimit: { type: [Number, String], default: null }, reverseYears: { type: Boolean, default: false }, keepActionRow: { type: Boolean, default: false }, weekPicker: { type: Boolean, default: false }, filters: { type: Object, default: () => ({}) } });
var sl = ce(K(K(K({}, Tn), Gt), Nn), { multiCalendars: { type: [Boolean, Number, String], default: null }, modelValue: { type: [String, Date, Array, Object], default: null }, position: { type: String, default: "center" }, dark: { type: Boolean, default: false }, format: { type: [String, Function], default: () => null }, closeOnScroll: { type: Boolean, default: false }, autoPosition: { type: Boolean, default: true }, closeOnAutoApply: { type: Boolean, default: true }, teleport: { type: [String, Object], default: "body" }, altPosition: { type: [Boolean, Function], default: false }, partialRange: { type: Boolean, default: true }, transitions: { type: Boolean, default: true }, formatLocale: { type: Object, default: null }, utc: { type: Boolean, default: false }, ariaLabels: { type: Object, default: () => ({}) } });
var In = { range: { type: Boolean, default: false }, multiCalendars: { type: Number, default: 0 }, internalModelValue: { type: [Date, Array], default: null } };
var Bn = ce(K(K({}, qt), In), { vertical: { type: Boolean, default: false }, month: { type: Number, default: 0 }, year: { type: Number, default: 0 }, instance: { type: Number, default: 1 } });
var ul = ["aria-label", "aria-disabled", "aria-readonly"];
var il = { key: 1, class: "dp__input_wrap" };
var dl = ["id", "name", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "onKeydown"];
var ml = { key: 4, class: "dp__clear_icon" };
var cl = defineComponent({ props: ce(K(K(K({}, Tn), Gt), zt), { inputValue: { type: String, default: "" }, inline: { type: Boolean, default: false }, isMenuOpen: { type: Boolean, default: false }, pattern: { type: String, default: "" } }), emits: ["clear", "open", "update:inputValue", "setInputDate", "close", "selectDate", "setEmptyDate"], setup(e, { expose: l, emit: n }) {
  const t = e, i = ref(), g = ref(null), b = ref(false), k = inject(Le), p = useSlots(), w = computed(() => ({ dp__pointer: !t.disabled && !t.readonly && !t.textInput, dp__disabled: t.disabled, dp__input: true, dp__input_icon_pad: !t.hideInputIcon, dp__input_valid: t.state, dp__input_invalid: t.state === false, dp__input_focus: b.value || t.isMenuOpen, [t.inputClassName]: !!t.inputClassName })), h = (u) => {
    const { value: r } = u.target, { format: T, rangeSeparator: S } = t.textInputOptions;
    if (r !== "") {
      if (t.range) {
        const [N, V] = r.split(`${S}`);
        if (N && V) {
          const Q = Et(N.trim(), T || t.pattern), C = Et(V.trim(), T || t.pattern);
          i.value = Q && C ? [Q, C] : null;
        }
      } else
        i.value = Et(r, T || t.pattern);
      n("setInputDate", i.value);
    } else
      n("setInputDate", null), t.autoApply && (n("setEmptyDate"), i.value = null);
    n("update:inputValue", r);
  }, O = () => {
    var u, r;
    ((u = t.textInputOptions) == null ? void 0 : u.enterSubmit) && Ft(i.value) && t.inputValue !== "" ? (n("setInputDate", i.value, true), i.value = null) : ((r = t.textInputOptions) == null ? void 0 : r.enterSubmit) && t.inputValue === "" && (i.value = null, n("clear"));
  }, M = () => {
    var u, r;
    ((u = t.textInputOptions) == null ? void 0 : u.tabSubmit) && Ft(i.value) && t.inputValue !== "" ? (n("setInputDate", i.value, true), i.value = null) : ((r = t.textInputOptions) == null ? void 0 : r.tabSubmit) && t.inputValue === "" && (i.value = null, n("clear")), n("close");
  }, H = () => {
    var u;
    !t.inline && (t.textInput ? t.textInput && ((u = t.textInputOptions) == null ? void 0 : u.openMenu) : true) && (b.value = true, t.openMenuOnFocus && !t.isMenuOpen ? n("open") : t.isMenuOpen && (a(), n("close")));
  }, W = () => {
    var u;
    (!t.openMenuOnFocus || p["dp-input"] || p.trigger) && (t.textInput && ((u = t.textInputOptions) == null ? void 0 : u.openMenu) && !t.isMenuOpen ? n("open") : t.textInput || n("open"));
  }, _ = () => {
    b.value = false, t.autoApply && t.textInput && i.value && (n("setInputDate", i.value), n("selectDate"), i.value = null);
  }, F = (u) => {
    u.stopImmediatePropagation();
  }, z = () => {
    n("clear");
  }, a = () => {
    b.value = false;
    const u = we(g);
    u && u.blur();
  };
  return l({ unFocus: a }), (u, r) => (openBlock(), createElementBlock("div", { onClick: W, "aria-label": unref(k).input, role: "textbox", "aria-multiline": "false", "aria-disabled": u.disabled, "aria-readonly": u.readonly }, [u.$slots.trigger && !u.$slots["dp-input"] && !e.inline ? renderSlot(u.$slots, "trigger", { key: 0 }) : createCommentVNode("", true), !u.$slots.trigger && (!e.inline || u.inlineWithInput) ? (openBlock(), createElementBlock("div", il, [u.$slots["dp-input"] && !u.$slots.trigger && !e.inline ? renderSlot(u.$slots, "dp-input", { key: 0, value: e.inputValue, onInput: h, onEnter: O, onTab: M, onClear: z }) : createCommentVNode("", true), u.$slots["dp-input"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("input", { key: 1, ref_key: "inputRef", ref: g, id: u.uid ? `dp-input-${u.uid}` : void 0, name: u.name, class: normalizeClass(unref(w)), placeholder: u.placeholder, disabled: u.disabled, readonly: u.readonly, required: u.required, value: e.inputValue, autocomplete: u.autocomplete, onInput: h, onKeydown: [withKeys(O, ["enter"]), withKeys(M, ["tab"])], onBlur: _, onFocus: H }, null, 42, dl)), u.$slots["input-icon"] && !u.hideInputIcon ? (openBlock(), createElementBlock("span", { key: 2, class: "dp__input_icon", onClick: F }, [renderSlot(u.$slots, "input-icon")])) : createCommentVNode("", true), !u.$slots["input-icon"] && !u.hideInputIcon && !u.$slots["dp-input"] ? (openBlock(), createBlock(unref($t), { key: 3, class: "dp__input_icon dp__input_icons", onClick: F })) : createCommentVNode("", true), u.$slots["clear-icon"] && u.clearable && !u.disabled && !u.readonly ? (openBlock(), createElementBlock("span", ml, [renderSlot(u.$slots, "clear-icon", { clear: z })])) : createCommentVNode("", true), u.clearable && !u.$slots["clear-icon"] && e.inputValue && !u.disabled && !u.readonly ? (openBlock(), createBlock(unref(ga), { key: 5, class: "dp__clear_icon dp__input_icons", onClick: withModifiers(z, ["stop", "prevent"]) }, null, 8, ["onClick"])) : createCommentVNode("", true)])) : createCommentVNode("", true)], 8, ul));
} });
var pl = ["aria-label"];
var vl = { class: "db__calendar_header", role: "row" };
var fl = { key: 0, class: "dp__calendar_header_item", role: "gridcell" };
var yl = createBaseVNode("div", { class: "dp__calendar_header_separator" }, null, -1);
var hl = ["aria-label"];
var gl = { key: 0, role: "gridcell", class: "dp__calendar_item dp__week_num" };
var wl = { class: "dp__cell_inner" };
var kl = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"];
var bl = createBaseVNode("div", { class: "dp__arrow_bottom_tp" }, null, -1);
var $l = defineComponent({ props: ce(K(K({}, Bn), Vn), { mappedDates: { type: Array, default: () => [] }, getWeekNum: { type: Function, default: () => "" }, modeHeight: { type: [Number, String], default: 255 }, specificMode: { type: Boolean, default: false } }), emits: ["selectDate", "setHoverDate", "handleScroll", "mount", "handleSwipe"], setup(e, { expose: l, emit: n }) {
  const t = e, i = ref(null), g = ref({ bottom: "", left: "", transform: "" }), b = ref([]), k = ref(null), p = ref(true), w = inject(Ct), h = inject(Le), O = ref(""), M = ref({ startX: 0, endX: 0, startY: 0, endY: 0 }), H = computed(() => Qa(t.locale, +t.weekStart));
  onMounted(() => {
    n("mount"), t.noSwipe || k.value && (k.value.addEventListener("touchstart", S), k.value.addEventListener("touchend", N), k.value.addEventListener("touchmove", V));
  });
  const W = (C, ne) => {
    if (w != null && w.value) {
      const Z = _e(Xe(new Date(), t.month, t.year));
      O.value = ge(_e(Xe(new Date(), C, ne)), Z) ? w.value[t.vertical ? "vNext" : "next"] : w.value[t.vertical ? "vPrevious" : "previous"], p.value = false, nextTick(() => {
        p.value = true;
      });
    }
  }, _ = computed(() => ({ dp__calendar_wrap: true, [t.calendarClassName]: !!t.calendarClassName })), F = computed(() => (C) => {
    const ne = ol(C);
    return { dp__marker_dot: ne.type === "dot", dp__marker_line: ne.type === "line" };
  }), z = computed(() => (C) => te(C, i.value)), a = computed(() => ({ dp__calendar: true, dp__calendar_next: t.multiCalendars > 0 && t.instance !== 0 })), u = computed(() => t.specificMode ? { height: `${t.modeHeight}px` } : null), r = (C, ne) => {
    var Z, v;
    if (n("setHoverDate", C), (v = (Z = C.marker) == null ? void 0 : Z.tooltip) != null && v.length) {
      const P = we(b.value[ne]);
      if (P) {
        const { width: Y, height: x } = P.getBoundingClientRect();
        g.value = { bottom: `${x}px`, left: `${Y / 2}px`, transform: "translateX(-50%)" }, i.value = C.value;
      }
    }
  }, T = () => {
    i.value = null;
  }, S = (C) => {
    M.value.startX = C.changedTouches[0].screenX, M.value.startY = C.changedTouches[0].screenY;
  }, N = (C) => {
    M.value.endX = C.changedTouches[0].screenX, M.value.endY = C.changedTouches[0].screenY, Q();
  }, V = (C) => {
    C.preventDefault();
  }, Q = () => {
    const C = t.vertical ? "Y" : "X";
    Math.abs(M.value[`start${C}`] - M.value[`end${C}`]) > 10 && n("handleSwipe", M.value[`start${C}`] > M.value[`end${C}`] ? "right" : "left");
  };
  return l({ triggerTransition: W }), (C, ne) => (openBlock(), createElementBlock("div", { class: normalizeClass(unref(a)) }, [createBaseVNode("div", { style: normalizeStyle(unref(u)) }, [e.specificMode ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", { key: 0, ref_key: "calendarWrapRef", ref: k, class: normalizeClass(unref(_)), role: "grid", "aria-label": unref(h).calendarWrap, onWheel: ne[1] || (ne[1] = withModifiers((Z) => C.$emit("handleScroll", Z), ["prevent"])) }, [createBaseVNode("div", vl, [C.weekNumbers ? (openBlock(), createElementBlock("div", fl, toDisplayString(C.weekNumName), 1)) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList(unref(H), (Z, v) => (openBlock(), createElementBlock("div", { class: "dp__calendar_header_item", role: "gridcell", key: v }, [C.$slots["calendar-header"] ? renderSlot(C.$slots, "calendar-header", { key: 0, day: Z, index: v }) : createCommentVNode("", true), C.$slots["calendar-header"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(Z), 1)], 64))]))), 128))]), yl, createVNode(Transition, { name: O.value, css: !!unref(w) }, { default: withCtx(() => [p.value ? (openBlock(), createElementBlock("div", { key: 0, class: "dp__calendar", role: "grid", "aria-label": unref(h).calendarDays }, [(openBlock(true), createElementBlock(Fragment, null, renderList(e.mappedDates, (Z, v) => (openBlock(), createElementBlock("div", { class: "dp__calendar_row", role: "row", key: v }, [C.weekNumbers ? (openBlock(), createElementBlock("div", gl, [createBaseVNode("div", wl, toDisplayString(e.getWeekNum(Z.days)), 1)])) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList(Z.days, (P, Y) => (openBlock(), createElementBlock("div", { role: "gridcell", class: "dp__calendar_item", ref_for: true, ref: (x) => {
    x && (b.value[Y + v] = x);
  }, key: Y + v, "aria-selected": P.classData.dp__active_date || P.classData.dp__range_start || P.classData.dp__range_start, "aria-disabled": P.classData.dp__cell_disabled, tabindex: "0", onClick: withModifiers((x) => C.$emit("selectDate", P), ["stop", "prevent"]), onKeydown: withKeys((x) => C.$emit("selectDate", P), ["enter"]), onMouseover: (x) => r(P, Y + v), onMouseleave: T }, [createBaseVNode("div", { class: normalizeClass(["dp__cell_inner", P.classData]) }, [C.$slots.day ? renderSlot(C.$slots, "day", { key: 0, day: +P.text, date: P.value }) : createCommentVNode("", true), C.$slots.day ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(P.text), 1)], 64)), P.marker ? (openBlock(), createElementBlock("div", { key: 2, class: normalizeClass(unref(F)(P.marker)), style: normalizeStyle(P.marker.color ? { backgroundColor: P.marker.color } : {}) }, null, 6)) : createCommentVNode("", true), unref(z)(P.value) ? (openBlock(), createElementBlock("div", { key: 3, class: "dp__marker_tooltip", style: normalizeStyle(g.value) }, [createBaseVNode("div", { class: "dp__tooltip_content", onClick: ne[0] || (ne[0] = withModifiers(() => {
  }, ["stop"])) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(P.marker.tooltip, (x, Ae) => (openBlock(), createElementBlock("div", { key: Ae, class: "dp__tooltip_text" }, [C.$slots["marker-tooltip"] ? renderSlot(C.$slots, "marker-tooltip", { key: 0, tooltop: x, day: P.value }) : createCommentVNode("", true), C.$slots["marker-tooltip"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createBaseVNode("div", { class: "dp__tooltip_mark", style: normalizeStyle(x.color ? { backgroundColor: x.color } : {}) }, null, 4), createBaseVNode("div", null, toDisplayString(x.text), 1)], 64))]))), 128)), bl])], 4)) : createCommentVNode("", true)], 2)], 40, kl))), 128))]))), 128))], 8, hl)) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"])], 42, pl))], 4)], 2));
} });
var Dl = (e) => typeof e == "object";
var Rn = (e, l) => l;
var Ml = (e) => Array.isArray(e) && e.length === 2;
var Sl = (e) => Array.isArray(e);
var Cl = (e) => typeof e == "object";
var mt = (e) => Array.isArray(e);
var Pe = (e) => Array.isArray(e);
var Pt = (e) => Array.isArray(e) && e.length === 2;
var Pl = (e, l) => l ? Array.isArray(e) : Pt(e);
var Al = (e) => Array.isArray(e);
var Tl = (e) => typeof e == "string" || typeof e == "object";
var Yn = (e) => typeof e == "string";
var _l = { class: "dp__selection_preview" };
var Ol = { class: "dp__action_buttons" };
var Vl = ["onKeydown"];
var Nl = defineComponent({ props: ce(K(K(K(K(K({}, On), Xt), _n), qt), In), { inline: { type: Boolean, default: false }, timePicker: { type: Boolean, default: false }, calendarWidth: { type: Number, default: 0 }, menuMount: { type: Boolean, default: false }, enableTimePicker: { type: Boolean, default: true } }), emits: ["closePicker", "selectDate"], setup(e, { emit: l }) {
  const n = e, t = inject(Cn), i = computed(() => ({ dp__action: true, dp__select: true, dp__action_disabled: !g.value || !b.value })), g = computed(() => n.enableTimePicker ? Kt(n.internalModelValue, n.maxTime, n.minTime) : true), b = computed(() => n.monthPicker ? Xa(n.internalModelValue, n.minDate, n.maxDate) : true), k = (h) => Mt(h, n.previewFormat, t == null ? void 0 : t.value), p = computed(() => !n.internalModelValue || !n.menuMount ? "" : typeof n.previewFormat == "string" ? mt(n.internalModelValue) ? n.internalModelValue.length === 2 && n.internalModelValue[1] ? n.multiCalendars > 0 ? `${k(n.internalModelValue[0])} - ${k(n.internalModelValue[1])}` : [k(n.internalModelValue[0]), k(n.internalModelValue[1])] : n.multiDates ? n.internalModelValue.map((h) => `${k(h)}`) : `${k(n.internalModelValue[0])} -` : Mt(n.internalModelValue, n.previewFormat, t == null ? void 0 : t.value) : n.timePicker ? n.previewFormat(Ht(n.internalModelValue)) : n.monthPicker ? n.previewFormat(Dt(n.internalModelValue)) : n.previewFormat(n.internalModelValue)), w = () => {
    g.value && b.value && l("selectDate");
  };
  return (h, O) => (openBlock(), createElementBlock("div", { class: "dp__action_row", style: normalizeStyle(e.calendarWidth ? { width: `${e.calendarWidth}px` } : {}) }, [createBaseVNode("div", _l, [h.$slots["action-preview"] ? renderSlot(h.$slots, "action-preview", { key: 0, value: h.internalModelValue }) : createCommentVNode("", true), h.$slots["action-preview"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [Array.isArray(unref(p)) ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [createTextVNode(toDisplayString(unref(p)), 1)], 64)), Array.isArray(unref(p)) ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(p), (M, H) => (openBlock(), createElementBlock("div", { key: H }, toDisplayString(M), 1))), 128)) : createCommentVNode("", true)], 64))]), createBaseVNode("div", Ol, [h.$slots["action-select"] ? renderSlot(h.$slots, "action-select", { key: 0, value: h.internalModelValue }) : createCommentVNode("", true), h.$slots["action-select"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [e.inline ? createCommentVNode("", true) : (openBlock(), createElementBlock("span", { key: 0, class: "dp__action dp__cancel", tabindex: "0", onClick: O[0] || (O[0] = (M) => h.$emit("closePicker")), onKeydown: O[1] || (O[1] = withKeys((M) => h.$emit("closePicker"), ["enter"])) }, toDisplayString(h.cancelText), 33)), createBaseVNode("span", { class: normalizeClass(unref(i)), tabindex: "0", onKeydown: withKeys(w, ["enter"]), onClick: w }, toDisplayString(h.selectText), 43, Vl)], 64))])], 4));
} });
var Il = { class: "dp__overlay_container", role: "grid" };
var Bl = { class: "dp__selection_grid_header" };
var Rl = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"];
var Yl = ["aria-label", "onKeydown"];
var At = defineComponent({ props: { items: { type: Array, default: () => [] }, modelValue: { type: [String, Number], default: null }, multiModelValue: { type: Array, default: () => [] }, disabledValues: { type: Array, default: () => [] }, minValue: { type: [Number, String], default: null }, maxValue: { type: [Number, String], default: null }, year: { type: Number, default: 0 }, skipActive: { type: Boolean, default: false } }, emits: ["update:modelValue", "selected", "toggle", "reset-flow"], setup(e, { emit: l }) {
  const n = e, t = ref(false), i = ref(null), g = ref(null), b = inject(jt, false), k = inject(Sn, ref(false)), p = inject(Le), w = ref();
  onBeforeUpdate(() => {
    i.value = null;
  }), onMounted(() => {
    _();
    const u = we(g);
    u && (k.value || u.focus({ preventScroll: true }), t.value = u.clientHeight < u.scrollHeight);
  });
  const h = computed(() => ({ dp__overlay: true })), O = computed(() => ({ dp__overlay_col: true })), M = computed(() => n.items.map((u) => u.filter((r) => r).map((r) => {
    var N, V, Q;
    const T = n.disabledValues.some((C) => C === r.value) || W(r.value), S = (N = n.multiModelValue) != null && N.length ? (V = n.multiModelValue) == null ? void 0 : V.some((C) => te(C, setYear(setMonth(new Date(), r.value), n.year))) : n.skipActive ? false : r.value === n.modelValue;
    return ce(K({}, r), { className: { dp__overlay_cell_active: S, dp__overlay_cell: !S, dp__overlay_cell_disabled: T, dp__overlay_cell_active_disabled: T && S, dp__overlay_cell_pad: true, dp__cell_in_between: (Q = n.multiModelValue) != null && Q.length ? z(r.value) : false } });
  }))), H = computed(() => ({ dp__button: true, dp__overlay_action: true, dp__over_action_scroll: t.value, dp__button_bottom: b })), W = (u) => {
    const r = n.maxValue ? +u > +n.maxValue : false, T = n.minValue ? +u < +n.minValue : false;
    return r || T;
  }, _ = () => {
    const u = we(i);
    if (u) {
      const r = we(g);
      r && (r.scrollTop = u.offsetTop - r.offsetTop - (r.getBoundingClientRect().height / 2 - u.getBoundingClientRect().height));
    }
  }, F = (u) => {
    !n.disabledValues.some((r) => r === u) && (n.minValue ? +n.minValue <= u : true) && (n.maxValue ? +n.maxValue >= u : true) && (l("update:modelValue", u), l("selected"));
  }, z = (u) => Dn(n.multiModelValue, setYear(setMonth(new Date(), w.value || 0), n.year), setYear(setMonth(new Date(), u), n.year)), a = () => {
    l("toggle"), l("reset-flow");
  };
  return (u, r) => (openBlock(), createElementBlock("div", { ref_key: "gridWrapRef", ref: g, class: normalizeClass(unref(h)), role: "dialog", tabindex: "0" }, [createBaseVNode("div", Il, [createBaseVNode("div", Bl, [renderSlot(u.$slots, "header")]), (openBlock(true), createElementBlock(Fragment, null, renderList(unref(M), (T, S) => (openBlock(), createElementBlock("div", { class: "dp__overlay_row", key: unref(ll)(S), role: "row" }, [(openBlock(true), createElementBlock(Fragment, null, renderList(T, (N) => (openBlock(), createElementBlock("div", { role: "gridcell", class: normalizeClass(unref(O)), key: N.value, "aria-selected": N.value === e.modelValue && !e.disabledValues.includes(N.value), "aria-disabled": N.className.dp__overlay_cell_disabled, ref_for: true, ref: (V) => {
    N.value === e.modelValue && !e.disabledValues.includes(N.value) && (i.value = V);
  }, tabindex: "0", onClick: (V) => F(N.value), onKeydown: withKeys((V) => F(N.value), ["enter"]), onMouseover: (V) => w.value = N.value }, [createBaseVNode("div", { class: normalizeClass(N.className) }, [u.$slots.item ? renderSlot(u.$slots, "item", { key: 0, item: N }) : createCommentVNode("", true), u.$slots.item ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(N.text), 1)], 64))], 2)], 42, Rl))), 128))]))), 128)), u.$slots["button-icon"] ? (openBlock(), createElementBlock("div", { key: 0, role: "button", "aria-label": unref(p).toggleOverlay, class: normalizeClass(unref(H)), tabindex: "0", onClick: a, onKeydown: withKeys(a, ["enter"]) }, [renderSlot(u.$slots, "button-icon")], 42, Yl)) : createCommentVNode("", true)])], 2));
} });
var Tt = () => {
  const e = inject(Ct);
  return { transitionName: computed(() => (l) => e != null && e.value ? l ? e.value.open : e.value.close : ""), showTransition: !!(e != null && e.value) };
};
var El = { key: 0, class: "dp__time_input" };
var Fl = createTextVNode(" : ");
var Ll = ["aria-label", "onKeydown", "onClick"];
var Hl = ["aria-label", "onKeydown", "onClick"];
var Wl = ["aria-label", "onKeydown", "onClick"];
var Ul = { key: 0 };
var Kl = ["aria-label", "onKeydown"];
var jl = defineComponent({ props: ce(K({}, Pn), { hours: { type: Number, default: 0 }, minutes: { type: Number, default: 0 }, seconds: { type: Number, default: 0 }, filters: { type: Object, default: () => ({}) }, disabled: { type: Boolean, default: false } }), emits: ["setHours", "setMinutes", "update:hours", "update:minutes", "update:seconds", "reset-flow"], setup(e, { expose: l, emit: n }) {
  const t = e, i = reactive({ hours: false, minutes: false, seconds: false }), g = ref("AM"), b = inject(Le), { transitionName: k, showTransition: p } = Tt(), w = computed(() => ({ dp__time_col: true, dp__time_col_reg: !t.enableSeconds && t.is24, dp__time_col_reg_with_button: !t.enableSeconds && !t.is24, dp__time_col_sec: t.enableSeconds && t.is24, dp__time_col_sec_with_button: t.enableSeconds && !t.is24 })), h = computed(() => {
    const r = [{ type: "hours" }, "separator", { type: "minutes" }];
    return t.enableSeconds ? r.concat(["separator", { type: "seconds" }]) : r;
  }), O = computed(() => h.value.filter((r) => typeof r != "string")), M = computed(() => (r) => {
    if (r === "hours") {
      const T = z(t.hours);
      return { text: T < 10 ? `0${T}` : `${T}`, value: T };
    }
    return { text: t[r] < 10 ? `0${t[r]}` : `${t[r]}`, value: t[r] };
  }), H = (r) => {
    const T = r === "hours" ? t.is24 ? 24 : 12 : 60, S = +t[`${r}GridIncrement`], N = [];
    for (let V = 0; V < T; V += S)
      N.push({ value: V, text: V < 10 ? `0${V}` : `${V}` });
    return Za(N);
  }, W = (r) => t[`no${r[0].toUpperCase() + r.slice(1)}Overlay`], _ = (r) => {
    W(r) || (i[r] = !i[r]);
  }, F = (r, T = true) => {
    const S = r === "hours" ? getHours : r === "minutes" ? getMinutes : getSeconds, N = T ? Ga : za;
    n(`update:${r}`, S(N({ [r]: +t[r] }, { [r]: +t[`${r}Increment`] })));
  }, z = (r) => t.is24 ? r : (r >= 12 ? g.value = "PM" : g.value = "AM", tl(r)), a = () => {
    g.value === "PM" ? (g.value = "AM", n("update:hours", t.hours - 12)) : (g.value = "PM", n("update:hours", t.hours + 12));
  };
  return l({ openChildCmp: (r) => {
    i[r] = true;
  } }), (r, T) => e.disabled ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", El, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(h), (S, N) => (openBlock(), createElementBlock("div", { key: N, class: normalizeClass(unref(w)) }, [S === "separator" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [Fl], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createBaseVNode("div", { class: "dp__inc_dec_button", role: "button", "aria-label": unref(b).incrementValue(S.type), tabindex: "0", onKeydown: withKeys((V) => F(S.type), ["enter"]), onClick: (V) => F(S.type) }, [r.$slots["arrow-up"] ? renderSlot(r.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true), r.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(hn), { key: 1 }))], 40, Ll), createBaseVNode("div", { role: "button", "aria-label": unref(b).openTpOverlay(S.type), class: normalizeClass(W(S.type) ? "" : "dp__time_display"), tabindex: "0", onKeydown: withKeys((V) => _(S.type), ["enter"]), onClick: (V) => _(S.type) }, [r.$slots[S.type] ? renderSlot(r.$slots, S.type, { key: 0, text: unref(M)(S.type).text, value: unref(M)(S.type).value }) : createCommentVNode("", true), r.$slots[S.type] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(unref(M)(S.type).text), 1)], 64))], 42, Hl), createBaseVNode("div", { class: "dp__inc_dec_button", role: "button", "aria-label": unref(b).decrementValue(S.type), tabindex: "0", onKeydown: withKeys((V) => F(S.type, false), ["enter"]), onClick: (V) => F(S.type, false) }, [r.$slots["arrow-down"] ? renderSlot(r.$slots, "arrow-down", { key: 0 }) : createCommentVNode("", true), r.$slots["arrow-down"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(gn), { key: 1 }))], 40, Wl)], 64))], 2))), 128)), r.is24 ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", Ul, [r.$slots["am-pm-button"] ? renderSlot(r.$slots, "am-pm-button", { key: 0, toggle: a, value: g.value }) : createCommentVNode("", true), r.$slots["am-pm-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", { key: 1, class: "dp__pm_am_button", role: "button", "aria-label": unref(b).amPmButton, tabindex: "0", onClick: a, onKeydown: withKeys(a, ["enter"]) }, toDisplayString(g.value), 41, Kl))])), (openBlock(true), createElementBlock(Fragment, null, renderList(unref(O), (S, N) => (openBlock(), createBlock(Transition, { key: N, name: unref(k)(unref(i)[S.type]), css: unref(p) }, { default: withCtx(() => [unref(i)[S.type] ? (openBlock(), createBlock(At, { key: 0, items: H(S.type), "disabled-values": e.filters.times[S.type], "onUpdate:modelValue": (V) => r.$emit(`update:${S.type}`, V), onSelected: (V) => _(S.type), onToggle: (V) => _(S.type), onResetFlow: T[0] || (T[0] = (V) => r.$emit("reset-flow")) }, createSlots({ "button-icon": withCtx(() => [r.$slots["clock-icon"] ? renderSlot(r.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true), r.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(yn), { key: 1 }))]), _: 2 }, [r.$slots[`${S.type}-overlay`] ? { name: "item", fn: withCtx(({ item: V }) => [renderSlot(r.$slots, `${S.type}-overlay`, { text: V.text, value: V.value })]) } : void 0]), 1032, ["items", "disabled-values", "onUpdate:modelValue", "onSelected", "onToggle"])) : createCommentVNode("", true)]), _: 2 }, 1032, ["name", "css"]))), 128))]));
} });
var ct = [{ name: "clock-icon", use: ["time", "calendar"] }, { name: "arrow-left", use: ["month-year", "calendar"] }, { name: "arrow-right", use: ["month-year", "calendar"] }, { name: "arrow-up", use: ["time", "calendar"] }, { name: "arrow-down", use: ["time", "calendar"] }, { name: "calendar-icon", use: ["month-year", "time", "calendar"] }, { name: "day", use: ["calendar"] }, { name: "month-overlay", use: ["calendar", "month-year"] }, { name: "year-overlay", use: ["calendar", "month-year"] }, { name: "hours-overlay", use: ["calendar", "time"] }, { name: "minutes-overlay", use: ["calendar", "time"] }, { name: "seconds-overlay", use: ["calendar", "time"] }, { name: "hours", use: ["calendar", "time"] }, { name: "minutes", use: ["calendar", "time"] }, { name: "month", use: ["calendar", "month-year"] }, { name: "year", use: ["calendar", "month-year"] }, { name: "action-select", use: ["action"] }, { name: "action-preview", use: ["action"] }, { name: "calendar-header", use: ["calendar"] }, { name: "marker-tooltip", use: ["calendar"] }, { name: "now-button", use: [] }, { name: "time-picker-overlay", use: ["calendar", "time"] }, { name: "am-pm-button", use: ["calendar", "time"] }];
var Gl = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }];
var zl = { all: () => ct, monthYear: () => ct.filter((e) => e.use.includes("month-year")), input: () => Gl, timePicker: () => ct.filter((e) => e.use.includes("time")), action: () => ct.filter((e) => e.use.includes("action")), calendar: () => ct.filter((e) => e.use.includes("calendar")) };
var qe = (e, l) => {
  const n = [];
  return zl[l]().forEach((t) => {
    e[t.name] && n.push(t.name);
  }), n;
};
var Xl = ["aria-label"];
var ql = { key: 0, class: "dp__overlay" };
var Jl = { class: "dp__overlay_container" };
var Zl = { key: 1, class: "dp__overlay_row" };
var Ql = ["aria-label"];
var xl = defineComponent({ props: ce(K({}, An), { range: { type: Boolean, default: false }, filters: { type: Object, default: () => ({}) }, hours: { type: [Number, Array], default: 0 }, minutes: { type: [Number, Array], default: 0 }, seconds: { type: [Number, Array], default: 0 }, customProps: { type: Object, default: null } }), emits: ["update:hours", "update:minutes", "update:seconds", "mount", "reset-flow"], setup(e, { expose: l, emit: n }) {
  const t = e, i = useSlots(), g = inject(jt, false), b = ref(null), k = inject(Le), { transitionName: p, showTransition: w } = Tt();
  onMounted(() => {
    n("mount");
  });
  const h = ref(false), O = (r) => ({ hours: Array.isArray(t.hours) ? t.hours[r] : t.hours, minutes: Array.isArray(t.minutes) ? t.minutes[r] : t.minutes, seconds: Array.isArray(t.seconds) ? t.seconds[r] : t.seconds }), M = computed(() => {
    const r = [];
    if (t.range)
      for (let T = 0; T < 2; T++)
        r.push(O(T));
    else
      r.push(O(0));
    return r;
  }), H = (r, T = false, S = "") => {
    T || n("reset-flow"), h.value = r, nextTick(() => {
      S !== "" && b.value && b.value.openChildCmp(S);
    });
  }, W = computed(() => ({ dp__button: true, dp__button_bottom: g })), _ = qe(i, "timePicker"), F = (r, T, S) => t.range ? T === 0 ? [r, M.value[1][S]] : [M.value[0][S], r] : r, z = (r) => {
    n("update:hours", r);
  }, a = (r) => {
    n("update:minutes", r);
  }, u = (r) => {
    n("update:seconds", r);
  };
  return l({ toggleTimePicker: H }), (r, T) => (openBlock(), createElementBlock("div", null, [r.timePicker ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", { key: 0, class: normalizeClass(unref(W)), role: "button", "aria-label": unref(k).openTimePicker, tabindex: "0", onKeydown: T[0] || (T[0] = withKeys((S) => H(true), ["enter"])), onClick: T[1] || (T[1] = (S) => H(true)) }, [r.$slots["clock-icon"] ? renderSlot(r.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true), r.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(yn), { key: 1 }))], 42, Xl)), createVNode(Transition, { name: unref(p)(h.value), css: unref(w) }, { default: withCtx(() => [h.value || r.timePicker ? (openBlock(), createElementBlock("div", ql, [createBaseVNode("div", Jl, [r.$slots["time-picker-overlay"] ? renderSlot(r.$slots, "time-picker-overlay", { key: 0, range: e.range, hours: e.hours, minutes: e.minutes, seconds: e.seconds, setHours: z, setMinutes: a, setSeconds: u }) : createCommentVNode("", true), r.$slots["time-picker-overlay"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", Zl, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(M), (S, N) => (openBlock(), createBlock(jl, mergeProps({ key: N, disabled: N === 0 ? r.fixedStart : r.fixedEnd, hours: S.hours, minutes: S.minutes, seconds: S.seconds, filters: e.filters }, { is24: r.is24, hoursGridIncrement: r.hoursGridIncrement, minutesGridIncrement: r.minutesGridIncrement, secondsGridIncrement: r.secondsGridIncrement, hoursIncrement: r.hoursIncrement, minutesIncrement: r.minutesIncrement, secondsIncrement: r.secondsIncrement, filters: e.filters, noHoursOverlay: r.noHoursOverlay, noMinutesOverlay: r.noMinutesOverlay, noSecondsOverlay: r.noSecondsOverlay, enableSeconds: r.enableSeconds }, { "onUpdate:hours": (V) => z(F(V, N, "hours")), "onUpdate:minutes": (V) => a(F(V, N, "minutes")), "onUpdate:seconds": (V) => u(F(V, N, "seconds")) }), createSlots({ _: 2 }, [renderList(unref(_), (V, Q) => ({ name: V, fn: withCtx((C) => [renderSlot(r.$slots, V, normalizeProps(guardReactiveProps(C)))]) }))]), 1040, ["disabled", "hours", "minutes", "seconds", "filters", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"]))), 128))])), r.timePicker ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", { key: 2, class: normalizeClass(unref(W)), role: "button", "aria-label": unref(k).closeTimePicker, tabindex: "0", onKeydown: T[2] || (T[2] = withKeys((S) => H(false), ["enter"])), onClick: T[3] || (T[3] = (S) => H(false)) }, [r.$slots["calendar-icon"] ? renderSlot(r.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true), r.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref($t), { key: 1 }))], 42, Ql))])])) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"])]));
} });
var eo = ["aria-label"];
var Jt = defineComponent({ props: { ariaLabel: { type: String, default: "" } }, emits: ["activate"], setup(e) {
  return (l, n) => (openBlock(), createElementBlock("div", { class: "dp__month_year_col_nav", onClick: n[0] || (n[0] = (t) => l.$emit("activate")), onKeydown: n[1] || (n[1] = withKeys((t) => l.$emit("activate"), ["enter"])), tabindex: "0" }, [createBaseVNode("div", { class: "dp__inner_nav", role: "button", "aria-label": e.ariaLabel }, [renderSlot(l.$slots, "default")], 8, eo)], 32));
} });
var to = ["aria-label"];
var En = defineComponent({ props: { ariaLabel: { type: String, default: "" }, showSelectionGrid: { type: Boolean, default: false }, modelValue: { type: Number, default: null }, items: { type: Array, default: () => [] }, disabledValues: { type: Array, default: () => [] }, minValue: { type: Number, default: null }, maxValue: { type: Number, default: null }, slotName: { type: String, default: "" } }, emits: ["update:model-value", "toggle"], setup(e) {
  const { transitionName: l, showTransition: n } = Tt();
  return (t, i) => (openBlock(), createElementBlock(Fragment, null, [createBaseVNode("div", { class: "dp__month_year_select", onClick: i[0] || (i[0] = (g) => t.$emit("toggle")), onKeydown: i[1] || (i[1] = withKeys((g) => t.$emit("toggle"), ["enter"])), role: "button", "aria-label": e.ariaLabel, tabindex: "0" }, [renderSlot(t.$slots, "default")], 40, to), createVNode(Transition, { name: unref(l)(e.showSelectionGrid), css: unref(n) }, { default: withCtx(() => [e.showSelectionGrid ? (openBlock(), createBlock(At, mergeProps({ key: 0 }, { modelValue: e.modelValue, items: e.items, disabledValues: e.disabledValues, minValue: e.minValue, maxValue: e.maxValue }, { "onUpdate:modelValue": i[2] || (i[2] = (g) => t.$emit("update:model-value", g)), onToggle: i[3] || (i[3] = (g) => t.$emit("toggle")) }), createSlots({ "button-icon": withCtx(() => [t.$slots["calendar-icon"] ? renderSlot(t.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true), t.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref($t), { key: 1 }))]), _: 2 }, [t.$slots[e.slotName] ? { name: "item", fn: withCtx(({ item: g }) => [renderSlot(t.$slots, e.slotName, { item: g })]) } : void 0]), 1040)) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"])], 64));
} });
var no = (e, l) => {
  const n = (p, w) => {
    let h = p;
    return e.filters.months.includes(getMonth(h)) ? (h = w ? addMonths(p, 1) : subMonths(p, 1), n(h, w)) : h;
  }, t = (p, w) => {
    let h = p;
    return e.filters.years.includes(getYear(h)) ? (h = w ? addYears(p, 1) : subYears(p, 1), t(h, w)) : h;
  }, i = (p, w, h) => [new Date(e[p]), set(new Date(), { month: w, year: h })], g = (p, w) => {
    e.preventMinMaxNavigation && (e.minDate || e.maxDate) ? (e.maxDate && (ge(...i("maxDate", p, w)) || te(...i("maxDate", p, w))) && k(p, w), (e.minDate && de(...i("minDate", p, w)) || te(...i("minDate", p, w))) && k(p, w)) : k(p, w);
  }, b = (p) => {
    const w = set(new Date(), { month: e.month, year: e.year });
    let h = p ? addMonths(w, 1) : subMonths(w, 1), O = getMonth(h), M = getYear(h);
    e.filters.months.includes(O) && (h = n(h, p), O = getMonth(h), M = getYear(h)), e.filters.years.includes(M) && (h = t(h, p), M = getYear(h)), g(O, M);
  }, k = (p, w) => {
    l("update:month", p), l("update:year", w);
  };
  return { handleMonthYearChange: b };
};
var ao = { class: "dp__month_year_row" };
var lo = { class: "dp__month_picker_header" };
var oo = ["aria-label"];
var ro = ["aria-label", "onKeydown"];
var so = ["aria-label"];
var uo = defineComponent({ props: ce(K(K({}, Bn), Xt), { preventMinMaxNavigation: { type: Boolean, default: false }, reverseYears: { type: Boolean, default: false }, years: { type: Array, default: () => [] }, months: { type: Array, default: () => [] }, filters: { type: Object, default: () => ({}) }, multiCalendarsSolo: { type: Boolean, default: false } }), emits: ["update:month", "update:year", "monthYearSelect", "mount", "reset-flow"], setup(e, { expose: l, emit: n }) {
  const t = e, { transitionName: i, showTransition: g } = Tt(), b = ref(false), k = ref(false), p = inject(Le), { handleMonthYearChange: w } = no(t, n);
  onMounted(() => {
    n("mount");
  });
  const h = (v) => ({ get: () => t[v], set: (P) => {
    n(`update:${v}`, P), n("monthYearSelect", v === "year"), v === "month" ? Q(true) : C(true);
  } }), O = computed(h("month")), M = computed(h("year")), H = computed(() => (v) => {
    const P = v === "month";
    return { showSelectionGrid: (P ? b : k).value, items: (P ? T : S).value, disabledValues: t.filters[P ? "months" : "years"], minValue: (P ? F : W).value, maxValue: (P ? z : _).value };
  }), W = computed(() => t.minDate ? getYear(new Date(t.minDate)) : null), _ = computed(() => t.maxDate ? getYear(new Date(t.maxDate)) : null), F = computed(() => {
    if (t.minDate && W.value) {
      if (W.value > t.year)
        return 12;
      if (W.value === t.year)
        return getMonth(new Date(t.minDate));
    }
    return null;
  }), z = computed(() => {
    if (t.maxDate && _.value) {
      if (_.value < t.year)
        return -1;
      if (_.value === t.year)
        return getMonth(new Date(t.maxDate));
    }
    return null;
  }), a = computed(() => t.range && t.internalModelValue && t.monthPicker ? t.internalModelValue : []), u = (v, P = false) => {
    const Y = [];
    for (let x = 0; x < v.length; x += 3) {
      const Ae = [v[x], v[x + 1], v[x + 2]];
      Y.push(P ? Ae.reverse() : Ae);
    }
    return P ? Y.reverse() : Y;
  }, r = computed(() => {
    const v = t.months.find((P) => P.value === t.month);
    return v || { text: "", value: 0 };
  }), T = computed(() => u(t.months)), S = computed(() => u(t.years, t.reverseYears)), N = computed(() => t.multiCalendars ? t.multiCalendarsSolo ? true : t.instance === 0 : true), V = computed(() => t.multiCalendars ? t.multiCalendarsSolo ? true : t.instance === t.multiCalendars - 1 : true), Q = (v = false) => {
    ne(v), b.value = !b.value;
  }, C = (v = false) => {
    ne(v), k.value = !k.value;
  }, ne = (v) => {
    v || n("reset-flow");
  }, Z = (v = false) => {
    n("update:year", v ? t.year + 1 : t.year - 1);
  };
  return l({ toggleMonthPicker: Q, toggleYearPicker: C }), (v, P) => (openBlock(), createElementBlock("div", ao, [v.monthPicker ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [unref(N) && !v.vertical ? (openBlock(), createBlock(Jt, { key: 0, "aria-label": unref(p).prevMonth, onActivate: P[0] || (P[0] = (Y) => unref(w)(false)) }, { default: withCtx(() => [v.$slots["arrow-left"] ? renderSlot(v.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true), v.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(vn), { key: 1 }))]), _: 3 }, 8, ["aria-label"])) : createCommentVNode("", true), createVNode(En, mergeProps({ "aria-label": unref(p).openMonthsOverlay, "slot-name": "month-overlay", modelValue: unref(O), "onUpdate:modelValue": P[1] || (P[1] = (Y) => isRef(O) ? O.value = Y : null) }, unref(H)("month"), { onToggle: Q }), createSlots({ default: withCtx(() => [v.$slots.month ? renderSlot(v.$slots, "month", normalizeProps(mergeProps({ key: 0 }, unref(r)))) : createCommentVNode("", true), v.$slots.month ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(unref(r).text), 1)], 64))]), _: 2 }, [v.$slots["calendar-icon"] ? { name: "calendar-icon", fn: withCtx(() => [renderSlot(v.$slots, "calendar-icon")]) } : void 0, v.$slots["month-overlay"] ? { name: "month-overlay", fn: withCtx(({ item: Y }) => [renderSlot(v.$slots, "month-overlay", { text: Y.text, value: Y.value })]) } : void 0]), 1040, ["aria-label", "modelValue"]), createVNode(En, mergeProps({ "aria-label": unref(p).openYearsOverlay, "slot-name": "year-overlay", modelValue: unref(M), "onUpdate:modelValue": P[2] || (P[2] = (Y) => isRef(M) ? M.value = Y : null) }, unref(H)("year"), { onToggle: C }), createSlots({ default: withCtx(() => [v.$slots.year ? renderSlot(v.$slots, "year", { key: 0, year: v.year }) : createCommentVNode("", true), v.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(v.year), 1)], 64))]), _: 2 }, [v.$slots["calendar-icon"] ? { name: "calendar-icon", fn: withCtx(() => [renderSlot(v.$slots, "calendar-icon")]) } : void 0, v.$slots["year-overlay"] ? { name: "year-overlay", fn: withCtx(({ item: Y }) => [renderSlot(v.$slots, "year-overlay", { text: Y.text, value: Y.value })]) } : void 0]), 1040, ["aria-label", "modelValue"]), unref(N) && v.vertical ? (openBlock(), createBlock(Jt, { key: 1, "aria-label": unref(p).prevMonth, onActivate: P[3] || (P[3] = (Y) => unref(w)(false)) }, { default: withCtx(() => [v.$slots["arrow-up"] ? renderSlot(v.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true), v.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(hn), { key: 1 }))]), _: 3 }, 8, ["aria-label"])) : createCommentVNode("", true), unref(V) ? (openBlock(), createBlock(Jt, { key: 2, "arial-label": unref(p).nextMonth, onActivate: P[4] || (P[4] = (Y) => unref(w)(true)) }, { default: withCtx(() => [v.$slots[v.vertical ? "arrow-down" : "arrow-right"] ? renderSlot(v.$slots, v.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : createCommentVNode("", true), v.$slots[v.vertical ? "arrow-down" : "arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(v.vertical ? unref(gn) : unref(fn)), { key: 1 }))]), _: 3 }, 8, ["arial-label"])) : createCommentVNode("", true)], 64)), v.monthPicker ? (openBlock(), createBlock(At, mergeProps({ key: 1 }, unref(H)("month"), { "skip-active": t.range, year: v.year, "multi-model-value": unref(a), modelValue: unref(O), "onUpdate:modelValue": P[10] || (P[10] = (Y) => isRef(O) ? O.value = Y : null), onToggle: Q }), createSlots({ header: withCtx(() => [createBaseVNode("div", lo, [createBaseVNode("div", { class: "dp__month_year_col_nav", tabindex: "0", onClick: P[5] || (P[5] = (Y) => Z(false)), onKeydown: P[6] || (P[6] = withKeys((Y) => Z(false), ["enter"])) }, [createBaseVNode("div", { class: "dp__inner_nav", role: "button", "aria-label": unref(p).prevMonth }, [v.$slots["arrow-left"] ? renderSlot(v.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true), v.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(vn), { key: 1 }))], 8, oo)], 32), createBaseVNode("div", { class: "dp__pointer", role: "button", "aria-label": unref(p).openYearsOverlay, tabindex: "0", onClick: C, onKeydown: withKeys(C, ["enter"]) }, [v.$slots.year ? renderSlot(v.$slots, "year", { key: 0, year: v.year }) : createCommentVNode("", true), v.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(v.year), 1)], 64))], 40, ro), createBaseVNode("div", { class: "dp__month_year_col_nav", tabindex: "0", onClick: P[7] || (P[7] = (Y) => Z(true)), onKeydown: P[8] || (P[8] = withKeys((Y) => Z(true), ["enter"])) }, [createBaseVNode("div", { class: "dp__inner_nav", role: "button", "aria-label": unref(p).nextMonth }, [v.$slots["arrow-right"] ? renderSlot(v.$slots, "arrow-right", { key: 0 }) : createCommentVNode("", true), v.$slots["arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(fn), { key: 1 }))], 8, so)], 32)]), createVNode(Transition, { name: unref(i)(k.value), css: unref(g) }, { default: withCtx(() => [k.value ? (openBlock(), createBlock(At, mergeProps({ key: 0 }, unref(H)("year"), { modelValue: unref(M), "onUpdate:modelValue": P[9] || (P[9] = (Y) => isRef(M) ? M.value = Y : null), onToggle: C }), createSlots({ "button-icon": withCtx(() => [v.$slots["calendar-icon"] ? renderSlot(v.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true), v.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref($t), { key: 1 }))]), _: 2 }, [v.$slots["year-overlay"] ? { name: "item", fn: withCtx(({ item: Y }) => [renderSlot(v.$slots, "year-overlay", { text: Y.text, value: Y.value })]) } : void 0]), 1040, ["modelValue"])) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"])]), _: 2 }, [v.$slots["month-overlay"] ? { name: "item", fn: withCtx(({ item: Y }) => [renderSlot(v.$slots, "month-overlay", { text: Y.text, value: Y.value })]) } : void 0]), 1040, ["skip-active", "year", "multi-model-value", "modelValue"])) : createCommentVNode("", true)]));
} });
var io = (e, l, n, t, i) => {
  const g = ref(new Date()), b = ref(), k = ref([{ month: getMonth(new Date()), year: getYear(new Date()) }]), p = ref(e.range ? [getHours(new Date()), getHours(new Date())] : getHours(new Date())), w = ref(e.range ? [getMinutes(new Date()), getMinutes(new Date())] : getMinutes(new Date())), h = ref(e.range ? [0, 0] : 0);
  watch(k, () => {
    setTimeout(() => {
      e.openOnTop && l("dpOpen");
    }, 0);
  }, { deep: true }), onMounted(() => {
    C(), a.value || (e.startDate && (k.value[0].month = getMonth(new Date(e.startDate)), k.value[0].year = getYear(new Date(e.startDate)), e.multiCalendars && fe(0)), e.startTime && z());
  });
  const O = computed(() => (o) => k.value[o] ? k.value[o].month : 0), M = computed(() => (o) => k.value[o] ? k.value[o].year : 0), H = (o, f, D) => {
    k.value[o].month = f, k.value[o].year = D;
  }, W = (o, f) => k.value[o].month = f, _ = (o, f) => k.value[o].year = f, F = (o = true) => e.enableSeconds ? Array.isArray(h.value) ? o ? h.value[0] : h.value[1] : h.value : 0, z = () => {
    e.startTime && (Al(e.startTime) ? (p.value = [+e.startTime[0].hours, +e.startTime[1].hours], w.value = [+e.startTime[0].minutes, +e.startTime[1].minutes], e.enableSeconds && (h.value = [+e.startTime[0].seconds, +e.startTime[1].seconds])) : (p.value = +e.startTime.hours, w.value = +e.startTime.minutes, e.enableSeconds && (h.value = +e.startTime.seconds)));
  }, a = computed({ get: () => e.internalModelValue, set: (o) => {
    !e.readonly && !e.disabled && l("update:internalModelValue", o);
  } });
  watch(a, () => C());
  const u = (o) => {
    const f = e.maxDate ? ge(be(o), be(new Date(e.maxDate))) : false, D = e.minDate ? de(be(o), be(new Date(e.minDate))) : false, G = typeof e.disabledDates == "function" ? e.disabledDates(o) : e.disabledDates.some(($e) => te(be(new Date($e)), be(o))), ke = (e.filters.months.length ? e.filters.months.map(($e) => +$e) : []).includes(getMonth(o)), Ue = e.disabledWeekDays.length ? e.disabledWeekDays.some(($e) => +$e === getDay(o)) : false, Ie = e.allowedDates.length ? !e.allowedDates.some(($e) => te(be(new Date($e)), be(o))) : false, Ke = getYear(o), Te = Ke < +e.yearRange[0] || Ke > +e.yearRange[1];
    return f || D || G || ke || Te || Ue || Ie;
  }, r = (o) => !a.value || e.hideOffsetDates && !o.current || e.range ? false : e.multiDates && Array.isArray(a.value) ? a.value.some((f) => te(f, o.value)) : te(o.value, a.value ? a.value : g.value), T = (o) => Dn(a.value, b.value, o.value), S = (o) => {
    if (W(0, getMonth(o)), _(0, getYear(o)), e.multiCalendars)
      for (let f = 1; f < e.multiCalendars; f++) {
        const D = set(new Date(), { month: O.value(f - 1), year: M.value(f - 1) }), G = add(D, { months: 1 });
        k.value.push({ month: getMonth(G), year: getYear(G) });
      }
  }, N = () => {
    if (Array.isArray(a.value) && a.value.length === 2) {
      const o = new Date(a.value[1] ? a.value[1] : addMonths(a.value[0], 1)), [f, D] = [getMonth(a.value[0]), getYear(a.value[0])], [G, ke] = [getMonth(a.value[1]), getYear(a.value[1])];
      (f !== G || f === G && D !== ke) && e.multiCalendarsSolo && (W(1, getMonth(o)), _(1, getYear(o)));
    }
  }, V = (o) => {
    S(o), p.value = getHours(o), w.value = getMinutes(o), h.value = getSeconds(o);
  }, Q = () => Array.isArray(a.value) && a.value.length ? a.value[a.value.length - 1] : null, C = () => {
    if (a.value)
      if (mt(a.value)) {
        if (a.value.length === 2 && !e.multiDates)
          S(a.value[0]), p.value = [getHours(a.value[0]), a.value[1] ? getHours(a.value[1]) : getHours(new Date())], w.value = [getMinutes(a.value[0]), a.value[1] ? getMinutes(a.value[1]) : getMinutes(new Date())], h.value = [getSeconds(a.value[0]), a.value[1] ? getSeconds(a.value[1]) : getSeconds(new Date())];
        else if (mt(a.value) && e.multiDates) {
          const o = a.value[a.value.length - 1];
          o && V(o);
        }
        e.multiCalendars && e.multiCalendarsSolo && N();
      } else
        V(a.value);
    else
      e.timePicker ? (z(), e.range ? Pe(p.value) && Pe(w.value) && (a.value = [ve(new Date(), p.value[0], w.value[0], F()), ve(new Date(), p.value[1], w.value[1], F(false))]) : a.value = ve(new Date(), p.value, w.value, F())) : e.monthPicker && !e.range ? a.value = Xe(new Date(), O.value(0), M.value(0)) : e.multiCalendars && S(new Date());
  }, ne = (o) => {
    const f = getMonth(new Date(o)), D = getYear(new Date(o));
    if (W(0, f), _(0, D), e.multiCalendars > 0)
      for (let G = 1; G < e.multiCalendars; G++) {
        const ke = ja(set(new Date(o), { year: O.value(G - 1), month: M.value(G - 1) }));
        W(G, ke.month), _(G, ke.year);
      }
  }, Z = (o) => {
    if (a.value && Array.isArray(a.value))
      if (a.value.some((f) => te(o, f))) {
        const f = a.value.filter((D) => !te(D, o));
        a.value = f.length ? f : null;
      } else
        (e.multiDatesLimit && +e.multiDatesLimit > a.value.length || !e.multiDatesLimit) && a.value.push(o);
    else
      a.value = [o];
  }, v = (o) => {
    if (Array.isArray(a.value) && a.value[0]) {
      const f = differenceInCalendarDays(o, a.value[0]), D = Math.abs(f < 0 ? f + 1 : f - 1);
      if (e.minRange && e.maxRange)
        return D >= +e.minRange && D <= +e.maxRange;
      if (e.minRange)
        return D >= +e.minRange;
      if (e.maxRange)
        return D <= +e.maxRange;
    }
    return true;
  }, P = (o) => Array.isArray(a.value) && a.value.length === 2 ? e.fixedStart && (ge(o, a.value[0]) || te(o, a.value[0])) ? [a.value[0], o] : e.fixedEnd && (de(o, a.value[1]) || te(o, a.value[1])) ? [o, a.value[1]] : a.value : [], Y = () => {
    e.autoApply && l("autoApply");
  }, x = (o, f = false) => {
    if (!u(o.value) && !(!o.current && e.hideOffsetDates)) {
      if (e.weekPicker)
        return a.value = St(new Date(o.value), +e.weekStart), Y();
      if (!e.range && !Pe(p.value) && !Pe(w.value)) {
        const D = ve(new Date(o.value), p.value, w.value, F());
        e.multiDates ? Z(D) : a.value = D, n(), Y();
      } else if (Pe(p.value) && Pe(w.value) && !e.multiDates) {
        let D = a.value ? a.value.slice() : [];
        D.length === 2 && !(e.fixedStart || e.fixedEnd) && (D = []), e.autoRange ? (f && ne(o.value), D = [new Date(o.value), addDays(new Date(o.value), +e.autoRange)]) : e.fixedStart || e.fixedEnd ? D = P(new Date(o.value)) : D[0] ? v(new Date(o.value)) && (de(new Date(o.value), new Date(D[0])) ? D.unshift(new Date(o.value)) : D[1] = new Date(o.value)) : D[0] = new Date(o.value), D[0] && !D[1] ? D[0] = ve(D[0], p.value[0], w.value[0], F()) : (D[0] = ve(D[0], p.value[0], w.value[0], F()), D[1] = ve(D[1], p.value[1], w.value[1], F(false)), n()), a.value = D, D[0] && D[1] && e.autoApply && l("autoApply");
      }
    }
  }, Ae = (o) => {
    const f = o.find((D) => D.current);
    return f ? getISOWeek(f.value) : "";
  }, Oe = (o) => {
    !o.current && e.hideOffsetDates || (b.value = o.value);
  }, Ve = (o) => {
    if (e.autoRange || e.weekPicker) {
      if (b.value) {
        if (e.hideOffsetDates && !o.current)
          return false;
        const f = addDays(b.value, +e.autoRange), D = St(new Date(b.value), +e.weekStart);
        return e.weekPicker ? te(D[1], new Date(o.value)) : te(f, new Date(o.value));
      }
      return false;
    }
    return false;
  }, Je = (o) => {
    if (e.autoRange || e.weekPicker) {
      if (b.value) {
        const f = addDays(b.value, +e.autoRange);
        if (e.hideOffsetDates && !o.current)
          return false;
        const D = St(new Date(b.value), +e.weekStart);
        return e.weekPicker ? ge(o.value, D[0]) && de(o.value, D[1]) : ge(o.value, b.value) && de(o.value, f);
      }
      return false;
    }
    return false;
  }, Ze = (o) => {
    if (e.autoRange || e.weekPicker) {
      if (b.value) {
        if (e.hideOffsetDates && !o.current)
          return false;
        const f = St(new Date(b.value), +e.weekStart);
        return e.weekPicker ? te(f[0], o.value) : te(b.value, o.value);
      }
      return false;
    }
    return false;
  }, fe = (o) => {
    for (let f = o - 1; f >= 0; f--) {
      const D = subMonths(set(new Date(), { month: O.value(f + 1), year: M.value(f + 1) }), 1);
      H(f, getMonth(D), getYear(D));
    }
    for (let f = o + 1; f <= e.multiCalendars - 1; f++) {
      const D = addMonths(set(new Date(), { month: O.value(f - 1), year: M.value(f - 1) }), 1);
      H(f, getMonth(D), getYear(D));
    }
  }, Ne = (o) => Xe(new Date(), O.value(o), M.value(o)), He = (o, f, D = true) => {
    if (D ? W(o, f) : _(o, f), e.multiCalendars && !e.multiCalendarsSolo && fe(o), e.monthPicker)
      if (e.range) {
        if (D) {
          let G = a.value ? a.value.slice() : [];
          G.length === 2 && (G = []), G.length ? de(Ne(o), G[0]) ? G.unshift(Ne(o)) : G.push(Ne(o)) : G = [Ne(o)], a.value = G;
        }
      } else
        a.value = Ne(o);
    n(), l("updateMonthYear", { instance: o, value: f, isMonth: D }), ot(e.multiCalendarsSolo ? o : void 0);
  }, me = (o) => ve(o, p.value, w.value, F()), Re = (o) => {
    mt(o) && mt(a.value) && Pe(p.value) && Pe(w.value) ? (o[0] && a.value[0] && (a.value[0] = ve(o[0], p.value[0], w.value[0], F())), o[1] && a.value[1] && (a.value[1] = ve(o[1], p.value[1], w.value[1], F(false)))) : e.multiDates && Array.isArray(a.value) ? a.value[a.value.length - 1] = me(o) : !e.range && !Pt(o) && (a.value = me(o)), l("timeUpdate");
  }, tt = (o, f = true, D = false) => {
    const G = f ? o : p.value, ke = !f && !D ? o : w.value, Ue = D ? o : h.value;
    if (e.range && Pt(a.value) && Pe(G) && Pe(ke) && Pe(Ue)) {
      const Ie = (Te) => ve(a.value[Te], G[Te], ke[Te], Ue[Te]), Ke = (Te) => setMilliseconds(a.value[Te], 0);
      if (te(a.value[0], a.value[1]) && (isAfter(Ie(0), Ke(1)) || isBefore(Ie(1), Ke(0))))
        return;
    }
    if (p.value = G, w.value = ke, h.value = Ue, a.value)
      if (e.multiDates) {
        const Ie = Q();
        Ie && Re(Ie);
      } else
        Re(a.value);
    else
      e.timePicker && Re(e.range ? [new Date(), new Date()] : new Date());
    n();
  }, nt = () => {
    b.value = null;
  }, m = (o) => Rn(a.value, e.range) && a.value[0] && b.value ? o ? ge(b.value, a.value[0]) : de(b.value, a.value[0]) : true, re = (o, f = true) => (e.range || e.weekPicker) && Pt(a.value) ? e.hideOffsetDates && !o.current ? false : te(new Date(o.value), a.value[f ? 0 : 1]) : e.range ? te(new Date(o.value), a.value && Array.isArray(a.value) ? f ? a.value[0] || null : a.value[1] : null) && (f ? !de(b.value || null, Array.isArray(a.value) ? a.value[0] : null) : true) || te(o.value, Array.isArray(a.value) ? a.value[0] : null) && m(f) : false, se = (o, f) => Array.isArray(e.internalModelValue) && e.internalModelValue.length || e.weekPicker ? false : !o && !r(f) && !(!f.current && e.hideOffsetDates) && (e.range ? !re(f) && !re(f, false) : true), at = (o, f, D) => Array.isArray(e.internalModelValue) && e.internalModelValue[0] && e.internalModelValue.length === 1 ? o ? false : D ? ge(e.internalModelValue[0], f.value) : de(e.internalModelValue[0], f.value) : false, We = (o = false) => {
    e.autoApply && e.monthPicker && l("autoApply", o);
  }, pt = (o, f) => {
    const D = set(new Date(), { month: O.value(f), year: M.value(f) }), G = o < 0 ? addMonths(D, 1) : subMonths(D, 1);
    H(f, getMonth(G), getYear(G)), e.multiCalendars && !e.multiCalendarsSolo && fe(f);
  }, Ot = (o, f) => {
    e.monthChangeOnScroll && (pt(e.monthChangeOnScroll !== "inverse" ? -o.deltaY : o.deltaY, f), ot());
  }, lt = (o, f, D = false) => {
    e.monthChangeOnArrows && e.vertical === D && vt(o, f);
  }, vt = (o, f) => {
    pt(o === "right" ? -1 : 1, f), ot();
  }, Vt = (o) => e.markers.find((f) => te(be(new Date(o.value)), be(new Date(f.date)))), Nt = () => {
    e.range ? Rn(a.value, e.range) && (a.value && a.value[0] ? a.value = de(new Date(), a.value[0]) ? [new Date(), a.value[0]] : [a.value[0], new Date()] : a.value = [new Date()]) : l("update:internalModelValue", new Date()), e.autoApply && l("selectDate");
  }, It = (o) => {
    o.length && o.length <= 2 && e.range && (a.value = o.map((f) => new Date(f)), e.autoApply && l("selectDate"));
  }, ot = (o) => {
    o || o === 0 ? t.value[o].triggerTransition(O.value(o), M.value(o)) : t.value.forEach((f, D) => f.triggerTransition(O.value(D), M.value(D)));
  };
  return { today: g, hours: p, minutes: w, seconds: h, month: O, year: M, monthYearSelect: We, isDisabled: u, updateTime: tt, setHoverDate: Oe, getWeekNum: Ae, selectDate: x, rangeActive: T, isActiveDate: r, updateMonthYear: He, isHoverRangeEnd: Ve, isAutoRangeInBetween: Je, isAutoRangeStart: Ze, clearHoverDate: nt, rangeActiveStartEnd: re, handleScroll: Ot, getMarker: Vt, handleArrow: lt, handleSwipe: vt, selectCurrentDate: Nt, isHoverDate: se, isHoverDateStartEnd: at, presetDateRange: It };
};
var mo = ["id", "aria-label", "onKeydown"];
var co = { key: 0, class: "dp__preset_ranges" };
var po = ["onClick"];
var vo = { key: 1, class: "dp__now_wrap" };
var fo = defineComponent({ props: ce(K(K(K({}, Nn), zt), Gt), { internalModelValue: { type: [Date, Array], default: null }, multiCalendars: { type: Number, default: 0 }, openOnTop: { type: Boolean, default: false } }), emits: ["update:internalModelValue", "closePicker", "selectDate", "dpOpen", "autoApply", "timeUpdate", "flow-step", "updateMonthYear"], setup(e, { emit: l }) {
  const n = e, t = useSlots(), i = ref(null), g = reactive({ timePicker: !n.enableTimePicker, monthYearInput: false, calendar: false }), b = ref([]), k = ref([]), p = ref(null), w = ref(null), h = ref(0), O = ref(false), M = ref(0), H = inject(Ct), W = inject(Le);
  onMounted(() => {
    var L;
    O.value = true, (L = n.presetRanges) != null && L.length || lt();
    const d = we(w);
    if (d && !n.textInput && !n.inline && d.focus({ preventScroll: true }), d) {
      const B = (j) => {
        j.stopImmediatePropagation(), j.stopPropagation();
      };
      d.addEventListener("pointerdown", B), d.addEventListener("mousedown", B);
    }
    document.addEventListener("resize", lt);
  }), onUnmounted(() => {
    document.removeEventListener("resize", lt);
  });
  const _ = () => {
    var d;
    ((d = n.flow) == null ? void 0 : d.length) && M.value !== -1 && (M.value += 1, l("flow-step", M.value), xt());
  }, F = () => {
    M.value = -1;
  }, { updateTime: z, updateMonthYear: a, today: u, month: r, year: T, hours: S, minutes: N, seconds: V, isDisabled: Q, isActiveDate: C, selectDate: ne, getWeekNum: Z, setHoverDate: v, isHoverRangeEnd: P, isAutoRangeInBetween: Y, isAutoRangeStart: x, rangeActive: Ae, clearHoverDate: Oe, rangeActiveStartEnd: Ve, monthYearSelect: Je, handleScroll: Ze, handleArrow: fe, handleSwipe: Ne, getMarker: He, selectCurrentDate: me, isHoverDateStartEnd: Re, isHoverDate: tt, presetDateRange: nt } = io(n, l, _, k), m = qe(t, "calendar"), re = qe(t, "action"), se = qe(t, "timePicker"), at = qe(t, "monthYear"), We = computed(() => n.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), pt = computed(() => xa(n.yearRange)), Ot = computed(() => el(n.locale, n.monthNameFormat)), lt = () => {
    const d = we(i);
    d && (h.value = d.getBoundingClientRect().width);
  }, vt = computed(() => (d) => Ja(r.value(d), T.value(d), +n.weekStart, n.hideOffsetDates)), Vt = computed(() => n.multiCalendars > 0 && n.range ? [...Array(n.multiCalendars).keys()] : [0]), Nt = computed(() => (d) => d === 1), It = computed(() => n.monthPicker || n.timePicker), ot = computed(() => ({ dp__flex_display: n.multiCalendars > 0 })), o = computed(() => ({ dp__instance_calendar: n.multiCalendars > 0 })), f = computed(() => ({ dp__menu_disabled: n.disabled, dp__menu_readonly: n.readonly })), D = computed(() => (d) => Ue(vt, d)), G = computed(() => ({ locale: n.locale, weekNumName: n.weekNumName, weekStart: n.weekStart, weekNumbers: n.weekNumbers, customProps: n.customProps, calendarClassName: n.calendarClassName, specificMode: It.value, getWeekNum: Z, multiCalendars: n.multiCalendars, modeHeight: n.modeHeight, internalModelValue: n.internalModelValue, noSwipe: n.noSwipe, vertical: n.vertical })), ke = computed(() => ({ dp__menu: true, dp__menu_index: !n.inline, dp__relative: n.inline, [n.menuClassName]: !!n.menuClassName })), Ue = (d, L) => d.value(L).map((B) => ce(K({}, B), { days: B.days.map((j) => {
    const U = Q(j.value), rt = tt(U, j);
    return j.marker = He(j), j.classData = { dp__cell_offset: !j.current, dp__pointer: !U && !(!j.current && n.hideOffsetDates), dp__active_date: n.range ? false : C(j), dp__date_hover: rt, dp__date_hover_start: Re(rt, j, true), dp__date_hover_end: Re(rt, j, false), dp__range_between: (n.range || n.weekPicker) && (n.multiCalendars > 0 ? j.current : true) && !U && !(!j.current && n.hideOffsetDates) && !C(j) ? Ae(j) : false, dp__today: !n.noToday && te(j.value, u.value) && j.current, dp__cell_disabled: U, dp__cell_auto_range: Y(j), dp__cell_auto_range_start: x(j), dp__cell_auto_range_end: P(j), dp__range_start: n.multiCalendars > 0 ? j.current && Ve(j) : Ve(j), dp__range_end: n.multiCalendars > 0 ? j.current && Ve(j, false) : Ve(j, false), [n.calendarCellClassName]: !!n.calendarCellClassName }, j;
  }) })), Ie = (d) => {
    d.stopPropagation(), d.preventDefault(), d.stopImmediatePropagation();
  }, Ke = () => {
    n.escClose && l("closePicker");
  }, Te = (d) => {
    d.stopImmediatePropagation(), d.preventDefault(), n.spaceConfirm && l("selectDate");
  }, $e = (d) => {
    var L;
    (L = n.flow) != null && L.length && (g[d] = true, Object.keys(g).filter((B) => !g[B]).length || xt());
  }, xt = () => {
    n.flow[M.value] === "month" && b.value[0] && b.value[0].toggleMonthPicker(true), n.flow[M.value] === "year" && b.value && b.value[0].toggleYearPicker(true), n.flow[M.value] === "calendar" && p.value && p.value.toggleTimePicker(false, true), n.flow[M.value] === "time" && p.value && p.value.toggleTimePicker(true, true);
    const d = n.flow[M.value];
    (d === "hours" || d === "minutes" || d === "seconds") && p.value && p.value.toggleTimePicker(true, true, d);
  };
  return (d, L) => (openBlock(), createBlock(Transition, { appear: "", name: unref(H).menuAppear, mode: "out-in", css: !!unref(H) }, { default: withCtx(() => [createBaseVNode("div", { id: d.uid ? `dp-menu-${d.uid}` : void 0, tabindex: "0", ref_key: "dpMenuRef", ref: w, role: "dialog", "aria-label": unref(W).menu, class: normalizeClass(unref(ke)), onMouseleave: L[11] || (L[11] = (...B) => unref(Oe) && unref(Oe)(...B)), onClick: Ie, onKeydown: [withKeys(Ke, ["esc"]), withKeys(Te, ["space"]), L[12] || (L[12] = withKeys((B) => unref(fe)("left", 0), ["left"])), L[13] || (L[13] = withKeys((B) => unref(fe)("left", 0, true), ["up"])), L[14] || (L[14] = withKeys((B) => unref(fe)("right", 0, true), ["down"])), L[15] || (L[15] = withKeys((B) => unref(fe)("right", 0), ["right"]))] }, [(d.disabled || d.readonly) && d.inline ? (openBlock(), createElementBlock("div", { key: 0, class: normalizeClass(unref(f)) }, null, 2)) : createCommentVNode("", true), d.inline ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", { key: 1, class: normalizeClass(unref(We)) }, null, 2)), createBaseVNode("div", { class: normalizeClass(d.presetRanges.length ? "dp__menu_content_wrapper" : null) }, [d.presetRanges.length ? (openBlock(), createElementBlock("div", co, [(openBlock(true), createElementBlock(Fragment, null, renderList(d.presetRanges, (B, j) => (openBlock(), createElementBlock("div", { key: j, class: "dp__preset_range", onClick: (U) => unref(nt)(B.range) }, toDisplayString(B.label), 9, po))), 128))])) : createCommentVNode("", true), createBaseVNode("div", { class: "dp__instance_calendar", ref_key: "calendarWrapperRef", ref: i, role: "document" }, [createBaseVNode("div", { class: normalizeClass(unref(ot)) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(Vt), (B, j) => (openBlock(), createElementBlock("div", { key: B, class: normalizeClass(unref(o)) }, [!d.disableMonthYearSelect && !d.timePicker ? (openBlock(), createBlock(resolveDynamicComponent(d.monthYearComponent ? d.monthYearComponent : uo), mergeProps({ key: 0, ref_for: true, ref: (U) => {
    U && (b.value[j] = U);
  } }, { months: unref(Ot), years: unref(pt), filters: d.filters, monthPicker: d.monthPicker, month: unref(r)(B), year: unref(T)(B), customProps: d.customProps, multiCalendars: e.multiCalendars, multiCalendarsSolo: d.multiCalendarsSolo, instance: B, minDate: d.minDate, maxDate: d.maxDate, preventMinMaxNavigation: d.preventMinMaxNavigation, internalModelValue: e.internalModelValue, range: d.range, reverseYears: d.reverseYears, vertical: d.vertical }, { onMount: L[0] || (L[0] = (U) => $e("monthYearInput")), onResetFlow: F, "onUpdate:month": (U) => unref(a)(B, U, true), "onUpdate:year": (U) => unref(a)(B, U, false), onMonthYearSelect: unref(Je) }), createSlots({ _: 2 }, [renderList(unref(at), (U, rt) => ({ name: U, fn: withCtx((Bt) => [renderSlot(d.$slots, U, normalizeProps(guardReactiveProps(Bt)))]) }))]), 1040, ["onUpdate:month", "onUpdate:year", "onMonthYearSelect"])) : createCommentVNode("", true), createVNode($l, mergeProps({ ref_for: true, ref: (U) => {
    U && (k.value[j] = U);
  } }, unref(G), { "flow-step": M.value, "onUpdate:flow-step": L[1] || (L[1] = (U) => M.value = U), instance: B, "mapped-dates": unref(D)(B), month: unref(r)(B), year: unref(T)(B), onSelectDate: (U) => unref(ne)(U, !unref(Nt)(B)), onSetHoverDate: L[2] || (L[2] = (U) => unref(v)(U)), onHandleScroll: (U) => unref(Ze)(U, B), onHandleSwipe: (U) => unref(Ne)(U, B), onMount: L[3] || (L[3] = (U) => $e("calendar")), onResetFlow: F }), createSlots({ _: 2 }, [renderList(unref(m), (U, rt) => ({ name: U, fn: withCtx((Bt) => [renderSlot(d.$slots, U, normalizeProps(guardReactiveProps(K({}, Bt))))]) }))]), 1040, ["flow-step", "instance", "mapped-dates", "month", "year", "onSelectDate", "onHandleScroll", "onHandleSwipe"])], 2))), 128))], 2), createBaseVNode("div", null, [d.enableTimePicker && !d.monthPicker && !d.weekPicker ? (openBlock(), createBlock(resolveDynamicComponent(d.timePickerComponent ? d.timePickerComponent : xl), mergeProps({ key: 0, ref_key: "timePickerRef", ref: p }, { is24: d.is24, hoursIncrement: d.hoursIncrement, minutesIncrement: d.minutesIncrement, hoursGridIncrement: d.hoursGridIncrement, secondsIncrement: d.secondsIncrement, minutesGridIncrement: d.minutesGridIncrement, secondsGridIncrement: d.secondsGridIncrement, noHoursOverlay: d.noHoursOverlay, noMinutesOverlay: d.noMinutesOverlay, noSecondsOverlay: d.noSecondsOverlay, range: d.range, filters: d.filters, timePicker: d.timePicker, hours: unref(S), minutes: unref(N), seconds: unref(V), customProps: d.customProps, enableSeconds: d.enableSeconds, fixedStart: d.fixedStart, fixedEnd: d.fixedEnd }, { onMount: L[4] || (L[4] = (B) => $e("timePicker")), "onUpdate:hours": L[5] || (L[5] = (B) => unref(z)(B)), "onUpdate:minutes": L[6] || (L[6] = (B) => unref(z)(B, false)), "onUpdate:seconds": L[7] || (L[7] = (B) => unref(z)(B, false, true)), onResetFlow: F }), createSlots({ _: 2 }, [renderList(unref(se), (B, j) => ({ name: B, fn: withCtx((U) => [renderSlot(d.$slots, B, normalizeProps(guardReactiveProps(U)))]) }))]), 1040)) : createCommentVNode("", true)])], 512), d.showNowButton ? (openBlock(), createElementBlock("div", vo, [d.$slots["now-button"] ? renderSlot(d.$slots, "now-button", { key: 0, selectCurrentDate: unref(me) }) : createCommentVNode("", true), d.$slots["now-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", { key: 1, type: "button", role: "button", class: "dp__now_button", onClick: L[8] || (L[8] = (...B) => unref(me) && unref(me)(...B)) }, toDisplayString(d.nowButtonLabel), 1))])) : createCommentVNode("", true)], 2), !d.autoApply || d.keepActionRow ? (openBlock(), createBlock(resolveDynamicComponent(d.actionRowComponent ? d.actionRowComponent : Nl), mergeProps({ key: 2 }, { calendarWidth: h.value, selectText: d.selectText, cancelText: d.cancelText, internalModelValue: e.internalModelValue, range: d.range, previewFormat: d.previewFormat, inline: d.inline, monthPicker: d.monthPicker, timePicker: d.timePicker, customProps: d.customProps, multiCalendars: e.multiCalendars, menuMount: O.value, maxTime: d.maxTime, minTime: d.minTime, enableTimePicker: d.enableTimePicker, minDate: d.minDate, maxDate: d.maxDate, multiDates: d.multiDates }, { onClosePicker: L[9] || (L[9] = (B) => d.$emit("closePicker")), onSelectDate: L[10] || (L[10] = (B) => d.$emit("selectDate")) }), createSlots({ _: 2 }, [renderList(unref(re), (B, j) => ({ name: B, fn: withCtx((U) => [renderSlot(d.$slots, B, normalizeProps(guardReactiveProps(K({}, U))))]) }))]), 1040)) : createCommentVNode("", true)], 42, mo)]), _: 3 }, 8, ["name", "css"]));
} });
var _t = ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(_t || {});
var yo = (e, l, n, t, i, g, b) => {
  const k = ref({ top: "0", left: "0", transform: "none" }), p = ref(false), w = 10, h = (a) => {
    const u = a.getBoundingClientRect();
    return { left: u.left + window.scrollX, top: u.top + window.scrollY };
  }, O = (a) => {
    let u = 0, r = 0;
    for (; a && !isNaN(a.offsetLeft) && !isNaN(a.offsetTop); )
      u += a.offsetLeft - a.scrollLeft, r += a.offsetTop - a.scrollTop, a = a.offsetParent;
    return { top: r, left: u };
  }, M = (a, u) => {
    k.value.left = `${a + u}px`, k.value.transform = "translateX(-100%)";
  }, H = (a) => {
    k.value.left = `${a}px`, k.value.transform = "translateX(0)";
  }, W = (a, u) => {
    e === _t.left && H(a), e === _t.right && M(a, u), e === _t.center && (k.value.left = `${a + u / 2}px`, k.value.transform = "translateX(-50%)");
  }, _ = () => {
    const a = we(i);
    if (a) {
      const { top: u } = l ? O(a) : h(a), { left: r, width: T } = a.getBoundingClientRect();
      k.value.top = `${u}px`, W(r, T);
    }
  }, F = (a = true) => {
    if (!g) {
      const u = we(i);
      if (l && typeof l != "boolean")
        k.value = l(u);
      else if (u) {
        const { left: r, width: T, height: S } = u.getBoundingClientRect(), { top: N } = l ? O(u) : h(u);
        k.value.top = `${S + N + w}px`, W(r, T), a && n && z();
      }
    }
  }, z = () => {
    const a = we(i);
    if (a && n && !g) {
      const { height: u, top: r, left: T, width: S } = a.getBoundingClientRect(), { top: N } = l ? O(a) : h(a), V = window.innerHeight - r - u, Q = we(t);
      if (Q) {
        const { height: C, left: ne, right: Z } = Q.getBoundingClientRect(), v = C + u;
        v > r && v > V ? r < V && (F(false), p.value = false) : v > V ? (k.value.top = `${N - C - w}px`, p.value = true) : (F(false), p.value = false), ne < 0 ? H(T) : Z > document.documentElement.clientWidth && M(T, S);
      }
    }
    b("recalculatePosition");
  };
  return { openOnTop: p, menuPosition: k, setMenuPosition: F, setInitialPosition: _, recalculatePosition: z };
};
var ho = (e, l, n, t, i, g, b, k, p, w, h, O, M, H) => {
  const W = ref(""), _ = ref();
  watch(_, () => {
    H("internalModelChange", _.value);
  });
  const F = (a) => {
    let u = null;
    a ? l ? Ml(a) && "hours" in a[0] && "minutes" in a[0] ? u = [ve(null, +a[0].hours, +a[0].minutes, +a[0].seconds), ve(null, +a[1].hours, +a[1].minutes, +a[1].seconds)] : Dl(a) && (u = ve(null, +a.hours, +a.minutes, +a.seconds)) : n ? Sl(a) && "month" in a[0] && "year" in a[0] ? u = [Xe(null, +a[0].month, +a[0].year), a[1] ? Xe(null, +a[1].month, +a[1].year) : null] : Cl(a) && "month" in a && "year" in a && (u = Xe(null, +a.month, +a.year)) : w && Array.isArray(a) ? u = a.map((r) => new Date(r)) : O && Array.isArray(a) ? u = [new Date(a[0]), new Date(a[1])] : t ? Pl(a, i) && (u = [new Date(a[0]), a[1] ? new Date(a[1]) : null]) : Tl(a) && (u = new Date(a)) : u = null, Ft(u) ? (_.value = u, z()) : (_.value = null, W.value = "");
  }, z = () => {
    if (!_.value)
      W.value = "";
    else if (!e || typeof e == "string") {
      const a = kn(e, g, k, n, l, O, b);
      Array.isArray(_.value) && w ? W.value = _.value.map((u) => Mt(u, a, p == null ? void 0 : p.value)).join("; ") : W.value = Mt(_.value, a, p == null ? void 0 : p.value, M == null ? void 0 : M.rangeSeparator);
    } else
      l ? W.value = e(Ht(_.value)) : n ? W.value = e(bn(_.value)) : W.value = e(_.value);
  };
  return { parseExternalModelValue: F, formatInputValue: z, internalModelValue: _, inputValue: W, emitModelValue: () => {
    if (n)
      H("update:modelValue", bn(_.value));
    else if (l)
      H("update:modelValue", Ht(_.value));
    else if (O)
      H("update:modelValue", _.value);
    else {
      _.value && t && i && _.value.length === 1 && _.value.push(null);
      const a = h ? Array.isArray(_.value) ? _.value.map((u) => u && be(u)) : be(_.value) : _.value;
      H("update:modelValue", a);
    }
    z();
  }, checkBeforeEmit: () => _.value ? t ? i ? _.value.length >= 1 : _.value.length === 2 : !!_.value : false };
};
var go = typeof window < "u" ? window : void 0;
var Zt = () => {
};
var wo = (e) => getCurrentScope() ? (onScopeDispose(e), true) : false;
var ko = (e, l, n, t) => {
  if (!e)
    return Zt;
  let i = Zt;
  const g = watch(() => unref(e), (k) => {
    i(), k && (k.addEventListener(l, n, t), i = () => {
      k.removeEventListener(l, n, t), i = Zt;
    });
  }, { immediate: true, flush: "post" }), b = () => {
    g(), i();
  };
  return wo(b), b;
};
var bo = (e, l, n, t = {}) => {
  const { window: i = go, event: g = "pointerdown" } = t;
  return i ? ko(i, g, (b) => {
    const k = we(e), p = we(l);
    !k || !p || k === b.target || b.composedPath().includes(k) || b.composedPath().includes(p) || n(b);
  }, { passive: true }) : void 0;
};
var $o = defineComponent({ props: K({}, sl), emits: ["update:modelValue", "textSubmit", "closed", "cleared", "open", "focus", "blur", "internalModelChange", "recalculatePosition", "flow-step", "updateMonthYear"], setup(e, { expose: l, emit: n }) {
  const t = e, i = useSlots(), g = ref(false), b = toRef(t, "modelValue"), k = ref(null), p = ref(null), w = ref(null);
  provide(jt, t.autoApply);
  const h = computed(() => t.formatLocale);
  provide(Cn, h), provide(Sn, toRef(t, "textInput")), onMounted(() => {
    r(t.modelValue), t.inline || (window.addEventListener("scroll", Oe), window.addEventListener("resize", Ve)), t.inline && (g.value = true);
  }), onUnmounted(() => {
    t.inline || (window.removeEventListener("scroll", Oe), window.removeEventListener("resize", Ve));
  });
  const O = qe(i, "all"), M = qe(i, "input");
  watch(b, () => {
    r(b.value);
  }, { deep: true });
  const { openOnTop: H, menuPosition: W, setMenuPosition: _, recalculatePosition: F, setInitialPosition: z } = yo(t.position, t.altPosition, t.autoPosition, k, p, t.inline, n), { internalModelValue: a, inputValue: u, parseExternalModelValue: r, emitModelValue: T, checkBeforeEmit: S, formatInputValue: N } = ho(t.format, t.timePicker, t.monthPicker, t.range, t.partialRange, t.is24, t.enableTimePicker, t.enableSeconds, h, t.multiDates, t.utc, t.weekPicker, t.textInputOptions, n), V = computed(() => ({ dp__main: true, dp__theme_dark: t.dark, dp__theme_light: !t.dark, dp__flex_display: t.inline, dp__flex_display_with_input: t.inlineWithInput })), Q = computed(() => Yn(t.format) ? t.format : kn(null, t.is24, t.enableSeconds, t.monthPicker, t.timePicker, t.weekPicker, t.enableTimePicker)), C = computed(() => t.previewFormat ? t.previewFormat : Yn(Q.value) ? Q.value : t.format), ne = computed(() => typeof t.transitions == "boolean" ? t.transitions ? Mn({}) : false : Mn(t.transitions));
  provide(Ct, ne);
  const Z = computed(() => t.dark ? "dp__theme_dark" : "dp__theme_light"), v = computed(() => Object.assign(nl(), t.textInputOptions)), P = computed(() => rl(t.ariaLabels));
  provide(Le, P);
  const Y = computed(() => al(t.filters)), x = computed(() => {
    const m = (re) => {
      const se = { hours: getHours(new Date()), minutes: getMinutes(new Date()), seconds: getSeconds(new Date()) };
      return Object.assign(se, re);
    };
    return t.range ? t.startTime && Array.isArray(t.startTime) ? [m(t.startTime[0]), m(t.startTime[1])] : null : t.startTime && !Array.isArray(t.startTime) ? m(t.startTime) : null;
  }), Ae = computed(() => t.multiCalendars === null ? 0 : typeof t.multiCalendars == "boolean" ? t.multiCalendars ? 2 : 0 : +t.multiCalendars >= 2 ? +t.multiCalendars : 2), Oe = () => {
    g.value && (t.closeOnScroll ? me() : t.autoPosition ? _() : window.removeEventListener("scroll", Oe));
  }, Ve = () => {
    g.value && _();
  }, Je = () => {
    !t.disabled && !t.readonly && (z(), g.value = true, nextTick().then(() => _()), g.value || He(), g.value && (n("open"), n("focus")), r(t.modelValue));
  }, Ze = () => {
    u.value = "", He(), n("update:modelValue", null), n("cleared"), me();
  }, fe = () => {
    S() && (T(), me());
  }, Ne = (m = false) => {
    t.autoApply && (t.enableTimePicker ? Kt(a.value, t.maxTime, t.minTime) : true) && (T(), t.closeOnAutoApply && !m && me());
  }, He = () => {
    a.value = null;
  }, me = () => {
    t.inline || (g.value && (g.value = false, n("closed"), n("blur"), z(), u.value && r(b.value)), He(), p.value && p.value.unFocus(), nt());
  }, Re = (m, re) => {
    if (!m) {
      a.value = null;
      return;
    }
    a.value = m, re && (fe(), n("textSubmit"));
  }, tt = () => {
    t.autoApply && Kt(a.value, t.maxTime, t.minTime) && T();
  }, nt = () => {
    w.value && w.value.focus({ preventScroll: true });
  };
  return bo(k, p, me), l({ closeMenu: me, selectDate: fe, clearValue: Ze, openMenu: Je, onScroll: Oe, formatInputValue: N }), (m, re) => (openBlock(), createElementBlock("div", { class: normalizeClass(unref(V)) }, [createVNode(cl, mergeProps({ ref_key: "inputRef", ref: p }, { placeholder: m.placeholder, hideInputIcon: m.hideInputIcon, readonly: m.readonly, disabled: m.disabled, inputClassName: m.inputClassName, clearable: m.clearable, state: m.state, inline: m.inline, inlineWithInput: m.inlineWithInput, textInput: m.textInput, textInputOptions: unref(v), range: m.range, isMenuOpen: g.value, pattern: unref(Q), autoApply: m.autoApply, uid: m.uid, openMenuOnFocus: m.openMenuOnFocus, required: m.required, name: m.name, autocomplete: m.autocomplete }, { "input-value": unref(u), "onUpdate:input-value": re[0] || (re[0] = (se) => isRef(u) ? u.value = se : null), onClear: Ze, onOpen: Je, onSetInputDate: Re, onSetEmptyDate: unref(T), onSelectDate: fe, onClose: me }), createSlots({ _: 2 }, [renderList(unref(M), (se, at) => ({ name: se, fn: withCtx((We) => [renderSlot(m.$slots, se, normalizeProps(guardReactiveProps(We)))]) }))]), 1040, ["input-value", "onSetEmptyDate"]), createBaseVNode("span", { tabindex: "-1", ref_key: "focusRef", ref: w }, null, 512), g.value ? (openBlock(), createBlock(Teleport, { key: 0, to: m.teleport, disabled: m.inline }, [g.value ? (openBlock(), createBlock(fo, mergeProps({ key: 0, ref_key: "dpMenuRef", ref: k, class: unref(Z), style: unref(W) }, { weekNumbers: m.weekNumbers, weekStart: m.weekStart, disableMonthYearSelect: m.disableMonthYearSelect, menuClassName: m.menuClassName, calendarClassName: m.calendarClassName, yearRange: m.yearRange, range: m.range, multiCalendars: unref(Ae), multiCalendarsSolo: m.multiCalendarsSolo, calendarCellClassName: m.calendarCellClassName, enableTimePicker: m.enableTimePicker, is24: m.is24, hoursIncrement: m.hoursIncrement, minutesIncrement: m.minutesIncrement, hoursGridIncrement: m.hoursGridIncrement, minutesGridIncrement: m.minutesGridIncrement, minDate: m.minDate, maxDate: m.maxDate, autoApply: m.autoApply, selectText: m.selectText, cancelText: m.cancelText, previewFormat: unref(C), locale: m.locale, weekNumName: m.weekNumName, disabledDates: m.disabledDates, filters: unref(Y), minTime: m.minTime, maxTime: m.maxTime, inline: m.inline, openOnTop: unref(H), monthPicker: m.monthPicker, timePicker: m.timePicker, monthNameFormat: m.monthNameFormat, startDate: m.startDate, startTime: unref(x), monthYearComponent: m.monthYearComponent, timePickerComponent: m.timePickerComponent, actionRowComponent: m.actionRowComponent, customProps: m.customProps, hideOffsetDates: m.hideOffsetDates, autoRange: m.autoRange, noToday: m.noToday, noHoursOverlay: m.noHoursOverlay, noMinutesOverlay: m.noMinutesOverlay, disabledWeekDays: m.disabledWeekDays, allowedDates: m.allowedDates, showNowButton: m.showNowButton, nowButtonLabel: m.nowButtonLabel, monthChangeOnScroll: m.monthChangeOnScroll, markers: m.markers, uid: m.uid, modeHeight: m.modeHeight, enableSeconds: m.enableSeconds, secondsIncrement: m.secondsIncrement, secondsGridIncrement: m.secondsGridIncrement, noSecondsOverlay: m.noSecondsOverlay, escClose: m.escClose, spaceConfirm: m.spaceConfirm, monthChangeOnArrows: m.monthChangeOnArrows, textInput: m.textInput, disabled: m.disabled, readonly: m.readonly, multiDates: m.multiDates, presetRanges: m.presetRanges, flow: m.flow, preventMinMaxNavigation: m.preventMinMaxNavigation, minRange: m.minRange, maxRange: m.maxRange, fixedStart: m.fixedStart, fixedEnd: m.fixedEnd, multiDatesLimit: m.multiDatesLimit, reverseYears: m.reverseYears, keepActionRow: m.keepActionRow, weekPicker: m.weekPicker, noSwipe: m.noSwipe, vertical: m.vertical }, { internalModelValue: unref(a), "onUpdate:internalModelValue": re[1] || (re[1] = (se) => isRef(a) ? a.value = se : null), onClosePicker: me, onSelectDate: fe, onDpOpen: unref(F), onAutoApply: Ne, onTimeUpdate: tt, onFlowStep: re[2] || (re[2] = (se) => m.$emit("flow-step", se)), onUpdateMonthYear: re[3] || (re[3] = (se) => m.$emit("updateMonthYear", se)) }), createSlots({ _: 2 }, [renderList(unref(O), (se, at) => ({ name: se, fn: withCtx((We) => [renderSlot(m.$slots, se, normalizeProps(guardReactiveProps(K({}, We))))]) }))]), 1040, ["class", "style", "internalModelValue", "onDpOpen"])) : createCommentVNode("", true)], 8, ["to", "disabled"])) : createCommentVNode("", true)], 2));
} });
var Qt = (() => {
  const e = $o;
  return e.install = (l) => {
    l.component("Vue3DatePicker", e);
  }, e;
})();
var Do = Object.freeze(Object.defineProperty({ __proto__: null, default: Qt }, Symbol.toStringTag, { value: "Module" }));
Object.entries(Do).forEach(([e, l]) => {
  e !== "default" && (Qt[e] = l);
});

// dep:@vuepic_vue-datepicker
var vuepic_vue_datepicker_default = Qt;
export {
  vuepic_vue_datepicker_default as default
};
//# sourceMappingURL=@vuepic_vue-datepicker.js.map
